<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Final Fantasy Trading Card Game Simulator</title>
    <!-- FFTCG Typography System -->
    <link rel="stylesheet" href="assets/css/fonts.css">
    <link rel="stylesheet" href="assets/css/main.css">
    <!-- FFTCG Theme Enhancements -->
    <link rel="stylesheet" href="assets/css/ff-theme.css">
    <!-- Component CSS files -->
    <link rel="stylesheet" href="assets/css/components/modals.css">
    <link rel="stylesheet" href="assets/css/components/deck-builder.css">
    <link rel="stylesheet" href="assets/css/components/lobby.css">
    <link rel="stylesheet" href="assets/css/components/game-board.css">
    <link rel="stylesheet" href="assets/css/components/hotkey-help.css">
    <link rel="stylesheet" href="assets/css/accessibility.css">
</head>
<body>
    <!-- Application Loading Screen -->
    <div id="loadingScreen" class="loading-screen ff-styled">
        <div class="loading-content">
            <div class="loading-logo ff-styled">‚ö°</div>
            <div class="loading-text">Loading Final Fantasy TCG Simulator...</div>
            <div class="loading-bar">
                <div class="loading-progress ff-styled" id="loadingProgress"></div>
            </div>
        </div>
    </div>

    <!-- Main Application Container -->
    <div id="app" class="app-container hidden">
        <!-- Header removed to save screen space -->

        <!-- Main Content Area -->
        <main class="app-main">
            <!-- Home View - Classic FF Main Menu -->
            <section id="homeView" class="view active">
                <canvas id="starfield"></canvas>
                
                <div class="ff-menu-container">
                    <h1 class="ff-game-title">FINAL FANTASY<br><span class="ff-subtitle">TRADING CARD GAME</span></h1>
                    
                    <ul class="ff-menu-list" id="ffMenuList">
                        <li class="ff-menu-item selected" data-action="multiplayer" tabindex="0">
                            <span class="ff-pointer">‚ñ∂</span> MULTIPLAYER 
                            <span class="ff-status" id="onlineCount">0 players online</span>
                        </li>
                        <li class="ff-menu-item" data-action="deck-builder" tabindex="0">
                            <span class="ff-pointer">‚ñ∂</span> DECK BUILDER 
                            <span class="ff-status" id="deckCount">0 decks saved</span>
                        </li>
                        <li class="ff-menu-item" data-action="practice" tabindex="0">
                            <span class="ff-pointer">‚ñ∂</span> PRACTICE vs AI 
                            <span class="ff-status">Ready to play</span>
                        </li>
                        <li class="ff-menu-item" data-action="tournament" tabindex="0">
                            <span class="ff-pointer">‚ñ∂</span> TOURNAMENT 
                            <span class="ff-status">No active tournaments</span>
                        </li>
                        <li class="ff-menu-item" data-action="rules" tabindex="0">
                            <span class="ff-pointer">‚ñ∂</span> GAME RULES 
                            <span class="ff-status">Learn the mechanics</span>
                        </li>
                        <li class="ff-menu-item" data-action="profile" tabindex="0">
                            <span class="ff-pointer">‚ñ∂</span> CHANGE PROFILE 
                            <span class="ff-status" id="profileName">Guest Player</span>
                        </li>
                        <li class="ff-menu-item" data-action="settings" tabindex="0">
                            <span class="ff-pointer">‚ñ∂</span> OPTIONS 
                            <span class="ff-status">Customize experience</span>
                        </li>
                    </ul>
                    
                    <p class="ff-footer">Final Fantasy Trading Card Game ¬© Square Enix</p>
                </div>
            </section>

            <!-- Deck Builder View -->
            <section id="deck-builderView" class="view">
                <canvas id="deckBuilderStarfield" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; z-index: -1; background: #000000; opacity: 0.8;"></canvas>
                
                <!-- Deck Manager - FF Party Status Style -->
                <div class="ff-container" id="deckManager">
                    <header class="ff-title-block">
                        <h1>DECK BUILDER<br><span class="ff-subtitle">Manage Your Decks</span></h1>
                    </header>
                    
                    <main class="ff-panel-layout single">
                        <section class="ff-panel wide">
                            <h2>Your Decks</h2>
                            <div class="ff-deck-grid" id="deckListContainer">
                                <!-- Deck list will be populated here -->
                            </div>
                            
                            <!-- No Decks Placeholder -->
                            <div id="noDecksPlaceholder" style="display: none; text-align: center; padding: 40px;">
                                <div style="font-size: 4rem; margin-bottom: 16px; opacity: 0.3;">üé¥</div>
                                <h3 style="color: #E8EEF5; margin-bottom: 12px;">No Decks Created</h3>
                                <p style="color: #9fb6cf; margin-bottom: 24px;">Create your first deck to get started building and playing!</p>
                                <button class="ff-button large" onclick="createNewDeckFF()">
                                    CREATE YOUR FIRST DECK
                                </button>
                            </div>
                            
                            <div class="ff-action-row center" style="margin-top: 24px;">
                                <button class="ff-button" onclick="testNewDeck()">
                                    + NEW DECK (TEST)
                                </button>
                                <button class="ff-button alt" onclick="window.importDeck()" title="Import deck from text">
                                    üì• IMPORT DECK
                                </button>
                                <button class="ff-button alt" onclick="goBackToMenu()" title="Return to main menu">
                                    üè† MAIN MENU
                                </button>
                            </div>
                        </section>
                    </main>
                    
                    <footer class="ff-footer">
                        Select a deck to edit ‚Ä¢ Create new decks ‚Ä¢ Import/Export deck lists
                    </footer>
                </div>

                <!-- Deck Editor - FF Modular Panel Design -->
                <div class="ff-container" id="deckEditor" style="display: none;">
                    <!-- Navigation Bar -->
                    <div class="ff-nav-bar" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; padding: 8px 0;">
                        <button class="ff-button alt" onclick="exitDeckEditor()" style="padding: 8px 16px; font-size: 0.9rem;">
                            ‚Üê Back to Decks
                        </button>
                        <button class="ff-button alt" onclick="goBackToMenu()" title="Return to main menu" style="padding: 8px 16px; font-size: 0.9rem;">
                            üè† Menu
                        </button>
                    </div>
                    
                    <!-- Title Block -->
                    <header class="ff-title-block" style="margin-top: 0;">
                        <h1 id="deckEditorTitle">DECK BUILDER<br><span class="ff-subtitle" id="deckEditorSubtitle">Create & Edit Your Deck</span></h1>
                    </header>
                    
                    <main class="ff-panel-layout triple">
                        <!-- Left Panel: Filters -->
                        <aside class="ff-panel filters">
                            <h3>FILTERS</h3>
                            
                            <!-- Search -->
                            <div style="margin-bottom: 16px;">
                                <label style="display: block; color: #c8d6e8; font-size: 0.8rem; margin-bottom: 4px;">Search:</label>
                                <input type="text" id="cardSearch" placeholder="Card name, text, or ID..." 
                                       style="width: 100%; padding: 6px 8px; background: rgba(255,255,255,0.1); border: 1px solid rgba(128,207,255,0.2); border-radius: 4px; color: white; font-size: 0.85rem;"
                                       onkeyup="if(window.app?.deckBuilder?.setSearchFilter) window.app.deckBuilder.setSearchFilter(this.value)">
                            </div>
                            
                            <!-- Sort -->
                            <div style="margin-bottom: 16px;">
                                <label style="display: block; color: #c8d6e8; font-size: 0.8rem; margin-bottom: 4px;">Sort By:</label>
                                <select id="sortSelect" style="width: 100%; padding: 6px; background: rgba(255,255,255,0.1); border: 1px solid rgba(128,207,255,0.2); border-radius: 4px; color: white; font-size: 0.85rem;" onchange="if(window.app?.deckBuilder?.setSortOrder) window.app.deckBuilder.setSortOrder(this.value)">
                                    <option value="name-asc">Name (A-Z)</option>
                                    <option value="name-desc">Name (Z-A)</option>
                                    <option value="cost-asc">Cost (Low‚ÜíHigh)</option>
                                    <option value="cost-desc">Cost (High‚ÜíLow)</option>
                                    <option value="id-asc">ID (Ascending)</option>
                                </select>
                            </div>
                            
                            <!-- Set/Opus Filter -->
                            <div style="margin-bottom: 10px;">
                                <label style="display: block; color: #c8d6e8; font-size: 0.8rem; margin-bottom: 4px;">Set/Opus:</label>
                                <select id="opusSelect" 
                                        style="width: 100%; padding: 6px; background: rgba(255,255,255,0.1); border: 1px solid rgba(128,207,255,0.2); border-radius: 4px; color: white; font-size: 0.85rem; font-family: 'Spectral', serif;" 
                                        onchange="handleOpusSelectChange(this)">
                                    <option value="">All Sets</option>
                                    <!-- Will be populated by JavaScript -->
                                </select>
                            </div>
                            
                            <!-- Element Filter -->
                            <div style="margin-bottom: 10px;">
                                <label style="display: block; color: #c8d6e8; font-size: 0.8rem; margin-bottom: 4px;">Element:</label>
                                <div id="elementButtons" style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px; font-size: 0.7rem;">
                                    <button class="filter-btn active" data-element="" onclick="toggleFilter(this, 'element', '')">All</button>
                                    <button class="filter-btn" data-element="fire" style="background: rgba(255,68,68,0.2);" onclick="toggleFilter(this, 'element', 'fire')">üî•</button>
                                    <button class="filter-btn" data-element="ice" style="background: rgba(68,221,255,0.2);" onclick="toggleFilter(this, 'element', 'ice')">‚ùÑÔ∏è</button>
                                    <button class="filter-btn" data-element="wind" style="background: rgba(68,255,68,0.2);" onclick="toggleFilter(this, 'element', 'wind')">üå™Ô∏è</button>
                                    <button class="filter-btn" data-element="lightning" style="background: rgba(170,68,255,0.2);" onclick="toggleFilter(this, 'element', 'lightning')">‚ö°</button>
                                    <button class="filter-btn" data-element="water" style="background: rgba(68,136,255,0.2);" onclick="toggleFilter(this, 'element', 'water')">üíß</button>
                                    <button class="filter-btn" data-element="earth" style="background: rgba(255,170,68,0.2);" onclick="toggleFilter(this, 'element', 'earth')">üåç</button>
                                    <button class="filter-btn" data-element="light" style="background: rgba(255,255,255,0.2);" onclick="toggleFilter(this, 'element', 'light')">‚òÄÔ∏è</button>
                                    <button class="filter-btn" data-element="dark" style="background: rgba(68,68,68,0.2);" onclick="toggleFilter(this, 'element', 'dark')">üåë</button>
                                </div>
                            </div>
                            
                            <!-- Type Filter -->
                            <div style="margin-bottom: 10px;">
                                <label style="display: block; color: #c8d6e8; font-size: 0.8rem; margin-bottom: 4px;">Type:</label>
                                <div id="typeButtons" style="display: flex; flex-direction: column; gap: 2px; font-size: 0.7rem;">
                                    <button class="filter-btn active" data-type="" onclick="toggleFilter(this, 'type', '')">All</button>
                                    <button class="filter-btn" data-type="forward" onclick="toggleFilter(this, 'type', 'forward')">‚öîÔ∏è Forward</button>
                                    <button class="filter-btn" data-type="backup" onclick="toggleFilter(this, 'type', 'backup')">üõ°Ô∏è Backup</button>
                                    <button class="filter-btn" data-type="summon" onclick="toggleFilter(this, 'type', 'summon')">‚ú® Summon</button>
                                </div>
                            </div>
                            
                            <!-- Cost Filter -->
                            <div style="margin-bottom: 10px;">
                                <label style="display: block; color: #c8d6e8; font-size: 0.8rem; margin-bottom: 4px;">Cost:</label>
                                <select id="costSelect" 
                                        style="width: 100%; padding: 6px; background: rgba(255,255,255,0.1); border: 1px solid rgba(128,207,255,0.2); border-radius: 4px; color: white; font-size: 0.85rem; font-family: 'Spectral', serif;" 
                                        onchange="handleCostSelectChange(this)">
                                    <option value="">All Costs</option>
                                    <option value="0">0</option>
                                    <option value="1">1</option>
                                    <option value="2">2</option>
                                    <option value="3">3</option>
                                    <option value="4">4</option>
                                    <option value="5">5</option>
                                    <option value="6">6</option>
                                    <option value="7">7</option>
                                    <option value="7+">7+</option>
                                </select>
                            </div>
                            
                            <!-- Rarity Filter -->
                            <div style="margin-bottom: 10px;">
                                <label style="display: block; color: #c8d6e8; font-size: 0.8rem; margin-bottom: 4px;">Rarity:</label>
                                <div id="rarityButtons" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 2px; font-size: 0.65rem;">
                                    <button class="filter-btn active" data-rarity="" onclick="toggleFilter(this, 'rarity', '')">All</button>
                                    <button class="filter-btn" data-rarity="C" onclick="toggleFilter(this, 'rarity', 'C')">C</button>
                                    <button class="filter-btn" data-rarity="R" onclick="toggleFilter(this, 'rarity', 'R')">R</button>
                                    <button class="filter-btn" data-rarity="H" onclick="toggleFilter(this, 'rarity', 'H')">H</button>
                                    <button class="filter-btn" data-rarity="L" onclick="toggleFilter(this, 'rarity', 'L')">L</button>
                                    <button class="filter-btn" data-rarity="S" onclick="toggleFilter(this, 'rarity', 'S')">S</button>
                                    <button class="filter-btn" data-rarity="B" onclick="toggleFilter(this, 'rarity', 'B')">B</button>
                                    <button class="filter-btn" data-rarity="PR" onclick="toggleFilter(this, 'rarity', 'PR')">PR</button>
                                </div>
                            </div>
                            
                            <!-- Categories Filter -->
                            <div style="margin-bottom: 10px;">
                                <label style="display: block; color: #c8d6e8; font-size: 0.8rem; margin-bottom: 4px;">Categories:</label>
                                <select id="categorySelect" 
                                        style="width: 100%; padding: 6px; background: rgba(255,255,255,0.1); border: 1px solid rgba(128,207,255,0.2); border-radius: 4px; color: white; font-size: 0.85rem; font-family: 'Spectral', serif;" 
                                        onchange="handleCategorySelectChange(this)">
                                    <option value="">All Categories</option>
                                    <!-- Will be populated by JavaScript -->
                                </select>
                            </div>
                            
                            <!-- Filter Controls -->
                            <button class="ff-button alt" onclick="clearAllDeckBuilderFilters()" style="width: 100%; margin-top: 10px; margin-bottom: 6px;">
                                CLEAR ALL FILTERS
                            </button>
                            <div id="filterResults" style="text-align: center; font-size: 0.7rem; color: #9fb6cf;">
                                Showing all cards
                            </div>
                        </aside>
                        
                        <!-- Center Panel: Card Grid -->
                        <section class="ff-panel grid-panel">
                            <div class="ff-card-grid" id="cardGrid">
                                <!-- Cards will be populated here -->
                            </div>
                        </section>
                        
                        <!-- Right Panel: Current Deck -->
                        <aside class="ff-panel deck-view">
                            <!-- Enhanced Deck Header with Statistics -->
                            <div style="margin-bottom: 16px;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                    <h3 style="margin: 0; color: #E8EEF5;">DECK</h3>
                                    <span id="deckCardCount" style="color: #80CFFF; font-size: 0.9rem; font-weight: 600;">0/50</span>
                                </div>
                                
                                <!-- Deck Statistics -->
                                <div id="deckStats" style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 12px;">
                                    <div style="background: rgba(128, 207, 255, 0.05); padding: 6px; border-radius: 4px; text-align: center;">
                                        <div style="font-size: 0.7rem; color: #9fb6cf; text-transform: uppercase;">Avg Cost</div>
                                        <div id="avgCost" style="color: #80CFFF; font-weight: 600;">0.0</div>
                                    </div>
                                    <div style="background: rgba(128, 207, 255, 0.05); padding: 6px; border-radius: 4px; text-align: center;">
                                        <div style="font-size: 0.7rem; color: #9fb6cf; text-transform: uppercase;">Elements</div>
                                        <div id="elementCount" style="color: #80CFFF; font-weight: 600;">0</div>
                                    </div>
                                </div>
                                
                                <!-- Element Distribution -->
                                <div id="elementDistribution" style="display: flex; gap: 2px; margin-bottom: 12px; min-height: 20px;">
                                    <!-- Element bars will be populated here -->
                                </div>
                            </div>
                            
                            <!-- Enhanced Deck Name Input -->
                            <input type="text" id="deckName" placeholder="Enter deck name..." 
                                   style="width: 100%; padding: 8px 12px; margin-bottom: 16px; background: rgba(255,255,255,0.08); border: 1px solid rgba(128,207,255,0.3); border-radius: 6px; color: #E8EEF5; font-family: 'Spectral', serif; font-size: 0.9rem;"
                                   onkeyup="updateDeckName()">
                            
                            <!-- Deck View Controls -->
                            <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                                <button class="filter-btn" id="deckSortBtn" onclick="toggleDeckSort()" title="Sort deck contents">
                                    SORT: NAME
                                </button>
                                <button class="filter-btn" id="deckViewBtn" onclick="toggleDeckView()" title="Toggle compact view">
                                    COMPACT
                                </button>
                            </div>
                            
                            <!-- Enhanced Deck List -->
                            <div id="currentDeckList" style="max-height: 280px; overflow-y: auto; margin-bottom: 16px; padding: 8px; background: rgba(0,0,0,0.15); border-radius: 6px; border: 1px solid rgba(128,207,255,0.1); scrollbar-width: thin; scrollbar-color: rgba(128, 207, 255, 0.6) rgba(0, 0, 0, 0.3);">
                                <div style="color: #9fb6cf; text-align: center; padding: 20px; font-style: italic; font-size: 0.85rem;">
                                    Add cards to see your deck
                                </div>
                            </div>
                            
                            <!-- Deck Validation Messages -->
                            <div id="deckValidation" style="margin-bottom: 12px; min-height: 20px;">
                                <!-- Validation messages will appear here -->
                            </div>
                            
                            <!-- Enhanced Deck Actions -->
                            <div style="display: flex; flex-direction: column; gap: 8px;">
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                                    <button class="ff-button" id="saveDeckBtn" onclick="saveDeckFF()" disabled title="Save deck to collection">
                                        üíæ SAVE
                                    </button>
                                    <button class="ff-button alt" onclick="window.exportDeck()" title="Export deck as file">
                                        üì§ EXPORT
                                    </button>
                                </div>
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                                    <button class="ff-button alt" onclick="window.importDeck()" title="Import deck from file">
                                        üìÅ IMPORT
                                    </button>
                                    <button class="ff-button alt" onclick="clearDeckFF()" style="color: #ff8080;" title="Clear all cards from deck">
                                        üóëÔ∏è CLEAR
                                    </button>
                                </div>
                            </div>
                        </aside>
                    </main>
                </div>
                
                <!-- Compatibility elements - make DeckBuilder.js work with our FF layout -->
                <div style="display: none;">
                    <div id="cardSearchPanel" style="display: block !important;">
                        <div id="cardDatabase"></div>
                    </div>
                    <!-- Add missing filter button containers that DeckBuilder.js expects -->
                    <div id="opusButtons" style="display: none;"></div>
                    <div id="categoryButtons" style="display: none;"></div>
                    <div id="costButtons" style="display: none;"></div>
                    <div id="rarityButtons"></div>
                    <div id="elementButtons"></div>
                    <div id="typeButtons"></div>
                    <!-- Add missing inputs that DeckBuilder expects -->
                    <input id="elementFilter" type="hidden">
                    <input id="typeFilter" type="hidden">
                    <div id="currentDeck"></div>
                </div>
                
            </section>

            <!-- Game View -->
            <section id="gameView" class="view">
                <div class="game-container">
                    <!-- Game Controls -->
                    <div class="game-controls">
                        <div class="game-menu-btn" onclick="toggleGameMenu()">
                            <span>‚ò∞</span>
                        </div>
                        
                        <!-- Removed duplicate turn indicators and buttons - using the ones in game-controls instead -->
                    </div>

                    <!-- Compact Game Menu (hidden by default) -->
                    <div class="game-menu" id="gameMenu" style="display: none;">
                        <div class="game-menu-content">
                            <button class="game-menu-item" onclick="toggleGameMenu()">
                                <span>‚öôÔ∏è</span> Settings
                            </button>
                            <button class="game-menu-item" onclick="showGameRules()">
                                <span>üìã</span> Rules
                            </button>
                            <button class="game-menu-item" onclick="confirmLeaveGame()">
                                <span>üö™</span> Leave Game
                            </button>
                            <button class="game-menu-item" onclick="toggleGameMenu()">
                                <span>‚úï</span> Close
                            </button>
                        </div>
                    </div>

                    <!-- Right-side Event Log (Toggleable) -->
                    <div class="right-event-log" id="rightEventLog">
                        <div class="event-log-toggle" id="eventLogToggle" onclick="toggleEventLog()">
                            <span class="toggle-icon">üìã</span>
                            <span class="toggle-text">Game Log</span>
                        </div>
                        <div class="event-log-panel" id="eventLogPanel">
                            <div class="event-log-panel-header">
                                <h3>Game Event Log</h3>
                                <div class="event-log-controls">
                                    <button class="event-log-filter" id="eventLogFilter" title="Filter Events">üîç</button>
                                    <button class="event-log-clear" id="clearRightEventLog" title="Clear Log">üóëÔ∏è</button>
                                    <button class="event-log-close" id="closeEventLog" onclick="toggleEventLog()" title="Close">√ó</button>
                                </div>
                            </div>
                            <div class="event-log-panel-content" id="eventLogPanelContent">
                                <div class="event-log-empty">Game events will appear here...</div>
                            </div>
                            <div class="event-log-panel-footer">
                                <div class="event-log-stats">
                                    <span id="eventLogCount">0 events</span>
                                    <span id="eventLogPhase">Main Phase 1</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Game Board - Simplified Layout -->
                    <div class="game-board" id="gameBoard">
                        <!-- Left Sidebar -->
                        <div class="game-sidebar-left">
                            <!-- Damage Zone Area Buttons -->
                            <div class="life-area-container">
                                <button class="life-area-btn opponent-life" onclick="openDamageZoneModal('opponent')" id="opponentLifeBtn">
                                    <div class="life-icon">üíî</div>
                                    <div class="life-count" id="opponentLifeCount">0</div>
                                    <div class="life-label">Opp Damage</div>
                                </button>
                                <button class="life-area-btn player-life" onclick="openDamageZoneModal('player')" id="playerLifeBtn">
                                    <div class="life-icon">‚ù§Ô∏è</div>
                                    <div class="life-count" id="playerLifeCount">0</div>
                                    <div class="life-label">Your Damage</div>
                                </button>
                            </div>

                            <!-- Card Preview Area -->
                            <div class="card-preview-area" id="cardPreviewArea">
                                <div class="card-preview-header">
                                    <h3 class="card-preview-title">Card Preview</h3>
                                </div>
                                <div class="card-preview-content" id="cardPreviewContent">
                                    <div class="card-preview-placeholder">
                                        Hover or click on a card to preview it here
                                    </div>
                                </div>
                            </div>

                            <!-- Crystal Points Display Area -->
                            <div class="cp-display-area" id="cpDisplayArea">
                                <div class="cp-display-header">
                                    <h4 class="cp-display-title">Crystal Points</h4>
                                </div>
                                <div class="cp-elements-grid" id="cpElementsGrid">
                                    <div class="cp-element fire" data-element="fire">
                                        <div class="cp-element-icon">üî•</div>
                                        <div class="cp-element-value" id="cpFire">0</div>
                                    </div>
                                    <div class="cp-element ice" data-element="ice">
                                        <div class="cp-element-icon">‚ùÑÔ∏è</div>
                                        <div class="cp-element-value" id="cpIce">0</div>
                                    </div>
                                    <div class="cp-element wind" data-element="wind">
                                        <div class="cp-element-icon">üå™Ô∏è</div>
                                        <div class="cp-element-value" id="cpWind">0</div>
                                    </div>
                                    <div class="cp-element lightning" data-element="lightning">
                                        <div class="cp-element-icon">‚ö°</div>
                                        <div class="cp-element-value" id="cpLightning">0</div>
                                    </div>
                                    <div class="cp-element water" data-element="water">
                                        <div class="cp-element-icon">üíß</div>
                                        <div class="cp-element-value" id="cpWater">0</div>
                                    </div>
                                    <div class="cp-element earth" data-element="earth">
                                        <div class="cp-element-icon">üåç</div>
                                        <div class="cp-element-value" id="cpEarth">0</div>
                                    </div>
                                    <div class="cp-element light" data-element="light">
                                        <div class="cp-element-icon">‚òÄÔ∏è</div>
                                        <div class="cp-element-value" id="cpLight">0</div>
                                    </div>
                                    <div class="cp-element dark" data-element="dark">
                                        <div class="cp-element-icon">üåë</div>
                                        <div class="cp-element-value" id="cpDark">0</div>
                                    </div>
                                </div>
                                <div class="cp-total">
                                    Total: <span id="cpTotalValue">0</span> CP
                                </div>
                            </div>

                            <!-- Event Log Area -->
                            <div class="event-log-area" id="eventLogArea">
                                <div class="event-log-header">
                                    <h4 class="event-log-title">Game Log</h4>
                                    <div class="event-log-controls">
                                        <button class="event-log-expand" id="expandEventLog" title="Open Event Log Viewer">üìã</button>
                                        <button class="event-log-minimize" id="minimizeEventLog" title="Minimize/Expand Log">‚ûñ</button>
                                        <button class="event-log-clear" id="clearEventLog" title="Clear Log">üóëÔ∏è</button>
                                    </div>
                                </div>
                                <div class="event-log-content" id="eventLogContent">
                                    <div class="event-log-inner-wrapper">
                                        <div class="event-log-empty">Game events will appear here...</div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Main Game Area -->
                        <div class="game-main-area">
                            <!-- Opponent Hand and CP Area -->
                            <div class="opponent-hand-cp-area">
                                <div class="hand-area opponent-hand-area">
                                    <div class="hand-header">Opponent Hand</div>
                                    <div class="hand-count" id="opponentHandCount">7 cards</div>
                                </div>
                                <div class="cp-display opponent-cp" id="opponentCP">
                                    <!-- CP icons will be dynamically generated based on deck elements -->
                                </div>
                                <!-- Opponent Damage Zone Display -->
                                <div class="damage-zone-display opponent-damage-zone">
                                    <div class="damage-zone-header">Opponent Damage Zone</div>
                                    <div class="damage-zone-grid" id="opponentDamageZone">
                                        <!-- Damage cards will appear here -->
                                    </div>
                                </div>
                                <div class="zone-buttons opponent-zone-buttons">
                                    <button class="zone-btn break-zone-btn" onclick="openZoneModal('opponent-break')" id="opponentBreakBtn" title="View Opponent Break Zone">
                                        <div class="zone-icon">üìö</div>
                                        <div class="zone-count" id="opponentBreakCount">0</div>
                                        <div class="zone-label">Break</div>
                                    </button>
                                    <button class="zone-btn removed-zone-btn" onclick="openZoneModal('opponent-removed')" id="opponentRemovedBtn" title="View Opponent Removed">
                                        <div class="zone-icon">üö´</div>
                                        <div class="zone-count" id="opponentRemovedCount">0</div>
                                        <div class="zone-label">Removed</div>
                                    </button>
                                </div>
                            </div>

                            <!-- Opponent Backups -->
                            <div class="game-zone opponent-backups" id="opponentBackups">
                                <div class="zone-content" id="opponentBackupsContent">
                                    <div class="zone-empty">Backup Area</div>
                                </div>
                                <span class="zone-count hidden" id="opponentBackupsCount">0</span>
                            </div>

                            <!-- Opponent Forwards -->
                            <div class="game-zone opponent-forwards" id="opponentBattlefield">
                                <div class="zone-content" id="opponentBattlefieldContent">
                                    <div class="zone-empty">Forward Area</div>
                                </div>
                                <span class="zone-count hidden" id="opponentBattlefieldCount">0</span>
                            </div>

                            <!-- Dynamic Switch Phase/End Turn Button -->
                            <div class="dynamic-action-area">
                                <div class="turn-info">
                                    <span class="current-player" id="currentPlayer">Your Turn</span>
                                    <span class="turn-phase" id="turnPhase">Main Phase</span>
                                </div>
                                <button class="dynamic-action-btn" id="dynamicActionBtn" onclick="handleDynamicAction()">Switch Phase</button>
                            </div>

                            <!-- Player Forwards -->
                            <div class="game-zone player-forwards" id="playerBattlefield">
                                <div class="zone-content" id="playerBattlefieldContent">
                                    <div class="zone-empty">Forward Area</div>
                                </div>
                                <span class="zone-count hidden" id="playerBattlefieldCount">0</span>
                            </div>

                            <!-- Player Backups -->
                            <div class="game-zone player-backups" id="playerBackups">
                                <div class="zone-content" id="playerBackupsContent">
                                    <div class="zone-empty">Backup Area</div>
                                </div>
                                <span class="zone-count hidden" id="playerBackupsCount">0</span>
                            </div>

                            <!-- Player Hand and CP Area -->
                            <div class="player-hand-cp-area">
                                <div class="hand-area player-hand-area" id="playerHand">
                                    <div class="hand-header">Your Hand</div>
                                    <div class="hand-content" id="playerHandContent">
                                        <!-- Player hand cards will appear here -->
                                    </div>
                                </div>
                                <div class="cp-display player-cp" id="playerCP">
                                    <!-- CP icons will be dynamically generated based on deck elements -->
                                </div>
                                <!-- Player Damage Zone Display -->
                                <div class="damage-zone-display player-damage-zone">
                                    <div class="damage-zone-header">Your Damage Zone</div>
                                    <div class="damage-zone-grid" id="playerDamageZone">
                                        <!-- Damage cards will appear here -->
                                    </div>
                                </div>
                                <div class="zone-buttons player-zone-buttons">
                                    <button class="zone-btn break-zone-btn" onclick="openZoneModal('player-break')" id="playerBreakBtn" title="View Break Zone (Graveyard)">
                                        <div class="zone-icon">üìö</div>
                                        <div class="zone-count" id="playerBreakCount">0</div>
                                        <div class="zone-label">Break</div>
                                    </button>
                                    <button class="zone-btn removed-zone-btn" onclick="openZoneModal('player-removed')" id="playerRemovedBtn" title="View Removed from Game">
                                        <div class="zone-icon">üö´</div>
                                        <div class="zone-count" id="playerRemovedCount">0</div>
                                        <div class="zone-label">Removed</div>
                                    </button>
                                </div>
                            </div>
                        </div>

                        <!-- NOTE: Floating Hand Cards removed - now integrated into game board layout -->

                        <!-- Hidden Zone Content for Unified Modal -->
                        <div style="display: none;">
                            <div id="playerDamageContent"></div>
                            <div id="playerBreakContent"></div>
                            <div id="playerRemovedContent"></div>
                            <div id="opponentDamageContent"></div>
                            <div id="opponentBreakContent"></div>
                            <div id="opponentRemovedContent"></div>
                        </div>

                        <!-- Card Context Menu -->
                        <div class="card-context-menu" id="cardContextMenu" style="display: none;">
                            <button class="context-menu-item" id="playCardOption">
                                <span class="context-icon">‚ö°</span>
                                <span class="context-text">Play Card</span>
                            </button>
                            <button class="context-menu-item" id="discardForCPOption">
                                <span class="context-icon">üî•</span>
                                <span class="context-text">Discard for 2 CP</span>
                            </button>
                            <button class="context-menu-item" id="tapBackupOption" style="display: none;">
                                <span class="context-icon">üíé</span>
                                <span class="context-text">Tap for 1 CP</span>
                            </button>
                            <button class="context-menu-item" id="viewCardOption">
                                <span class="context-icon">üëÅÔ∏è</span>
                                <span class="context-text">View Details</span>
                            </button>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Profile View -->
            <section id="profileView" class="view">
                <div class="profile-container ff-styled">
                    <h2 class="fftcg-title">Player Profile</h2>
                    
                    <!-- Settings Section -->
                    <div class="ff-card" style="margin-top: 24px;">
                        <h3 style="color: var(--color-primary); margin-bottom: 16px;">Audio Settings</h3>
                        <div style="margin-bottom: 12px;">
                            <label style="display: flex; align-items: center; gap: 12px; color: var(--text-secondary); cursor: pointer;">
                                <input type="checkbox" id="enableFFSounds" onchange="toggleFFSounds(this.checked)" style="transform: scale(1.2);">
                                Enable Final Fantasy Sound Effects
                            </label>
                            <p style="font-size: 0.85rem; color: var(--text-muted); margin: 8px 0 0 32px;">
                                Adds authentic FF menu and game sounds (requires page reload)
                            </p>
                        </div>
                        <div style="margin-bottom: 12px;">
                            <label style="display: block; color: var(--text-secondary); margin-bottom: 4px;">Sound Volume:</label>
                            <input type="range" id="soundVolume" min="0" max="100" value="30" 
                                   onchange="setSoundVolume(this.value)" 
                                   style="width: 100%; margin-bottom: 4px;">
                            <div style="color: var(--text-muted); font-size: 0.85rem; text-align: center;" id="volumeDisplay">30%</div>
                        </div>
                    </div>
                    
                    <!-- Profile management interface -->
                </div>
            </section>

            <!-- Card Browser View -->
            <section id="card-browserView" class="view">
                <canvas id="cardBrowserStarfield" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; z-index: -1; background: #000000;"></canvas>
                <div class="ff-container">
                    <header class="ff-title-block">
                        <h1>CARD BROWSER<br><span class="ff-subtitle">Browse All Cards</span></h1>
                    </header>
                    
                    <main class="ff-panel-layout triple">
                        <!-- Left Panel: Filters -->
                        <aside class="ff-panel filters">
                            <h3>FILTERS</h3>
                            
                            <!-- Element Filter -->
                            <div style="margin-bottom: 16px;">
                                <label style="display: block; color: #c8d6e8; font-size: 0.8rem; margin-bottom: 6px;">Element:</label>
                                <select id="browserElementFilter" style="width: 100%; padding: 6px; background: rgba(255,255,255,0.1); border: 1px solid rgba(128,207,255,0.2); border-radius: 4px; color: white; font-size: 0.85rem;">
                                    <option value="">All</option>
                                    <option value="fire">üî• Fire</option>
                                    <option value="ice">‚ùÑÔ∏è Ice</option>
                                    <option value="wind">üå™Ô∏è Wind</option>
                                    <option value="lightning">‚ö° Lightning</option>
                                    <option value="water">üíß Water</option>
                                    <option value="earth">üåç Earth</option>
                                    <option value="light">‚òÄÔ∏è Light</option>
                                    <option value="dark">üåë Dark</option>
                                </select>
                            </div>
                            
                            <!-- Cost Filter -->
                            <div style="margin-bottom: 16px;">
                                <label style="display: block; color: #c8d6e8; font-size: 0.8rem; margin-bottom: 6px;">Cost:</label>
                                <input type="range" id="browserCostFilter" min="0" max="8" value="4" 
                                       style="width: 100%; margin-bottom: 4px;" 
                                       oninput="document.getElementById('costValue').textContent = this.value === '0' ? 'All' : this.value">
                                <div style="color: #80CFFF; font-size: 0.8rem; text-align: center;" id="costValue">All</div>
                            </div>
                            
                            <!-- Type Filter -->
                            <div style="margin-bottom: 16px;">
                                <label style="display: block; color: #c8d6e8; font-size: 0.8rem; margin-bottom: 6px;">Type:</label>
                                <select id="browserTypeFilter" style="width: 100%; padding: 6px; background: rgba(255,255,255,0.1); border: 1px solid rgba(128,207,255,0.2); border-radius: 4px; color: white; font-size: 0.85rem;">
                                    <option value="">All</option>
                                    <option value="forward">‚öîÔ∏è Forward</option>
                                    <option value="backup">üõ°Ô∏è Backup</option>
                                    <option value="summon">‚ú® Summon</option>
                                </select>
                            </div>
                            
                            <div style="height: 20px;"></div>
                            <button class="ff-button alt" onclick="clearBrowserFilters()" style="width: 100%;">
                                CLEAR FILTERS
                            </button>
                        </aside>
                        
                        <!-- Center Panel: Card Grid -->
                        <section class="ff-panel grid-panel">
                            <div class="ff-card-grid" id="browserCardGrid">
                                <!-- Sample cards for demonstration -->
                                <div class="card-thumb">
                                    <div class="thumb-img">1</div>
                                    <div class="thumb-title">Card 1</div>
                                </div>
                                <div class="card-thumb">
                                    <div class="thumb-img">2</div>
                                    <div class="thumb-title">Card 2</div>
                                </div>
                                <div class="card-thumb">
                                    <div class="thumb-img">3</div>
                                    <div class="thumb-title">Card 3</div>
                                </div>
                                <div class="card-thumb">
                                    <div class="thumb-img">4</div>
                                    <div class="thumb-title">Card 4</div>
                                </div>
                                <div class="card-thumb">
                                    <div class="thumb-img">5</div>
                                    <div class="thumb-title">Card 5</div>
                                </div>
                                <div class="card-thumb">
                                    <div class="thumb-img">6</div>
                                    <div class="thumb-title">Card 6</div>
                                </div>
                                <div class="card-thumb">
                                    <div class="thumb-img">7</div>
                                    <div class="thumb-title">Card 7</div>
                                </div>
                                <div class="card-thumb">
                                    <div class="thumb-img">8</div>
                                    <div class="thumb-title">Card 8</div>
                                </div>
                                <div class="card-thumb">
                                    <div class="thumb-img">9</div>
                                    <div class="thumb-title">Card 9</div>
                                </div>
                                <div class="card-thumb">
                                    <div class="thumb-img">10</div>
                                    <div class="thumb-title">Card 10</div>
                                </div>
                            </div>
                        </section>
                        
                        <!-- Right Panel: Deck View -->
                        <aside class="ff-panel deck-view">
                            <h3>QUICK DECK (40 / 50)</h3>
                            <div class="deck-list" id="browserDeckView">
                                <div class="deck-row">Ifrit x1</div>
                                <div class="deck-row">Shiva x2</div>
                                <div class="deck-row">Cloud x3</div>
                            </div>
                            <div class="ff-action-row" style="margin-top: 16px;">
                                <button class="ff-button">SAVE DECK</button>
                                <button class="ff-button alt">EXIT</button>
                            </div>
                        </aside>
                    </main>
                    
                    <footer class="ff-footer">
                        Browsing 3,800+ cards ‚Ä¢ Use filters to narrow search
                    </footer>
                </div>
            </section>

            <!-- Practice Lobby View -->
            <section id="practice-lobbyView" class="view">
                <canvas id="practiceStarfield" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; z-index: -1; background: #000000;"></canvas>
                
                <div class="ff-container">
                    <header class="ff-title-block">
                        <h1>PRACTICE VS AI<br><span class="ff-subtitle">Training Mode</span></h1>
                    </header>
                    
                    <main class="ff-panel-layout">
                        <!-- Deck Selection Panel -->
                        <section class="ff-panel left-panel">
                            <h2>SELECT DECK</h2>
                            <ul class="ff-list" id="practiceDeckList">
                                <!-- Populated by JavaScript -->
                            </ul>
                            <div class="ff-action-row">
                                <button class="ff-button alt" onclick="window.app.switchView('deck-builder')">
                                    CREATE DECK
                                </button>
                            </div>
                            
                            <!-- Selected Deck Preview (hidden by default) -->
                            <div id="selectedDeckPreview" style="display: none; margin-top: 16px; padding-top: 16px; border-top: 1px solid rgba(128, 207, 255, 0.2);">
                                <div class="deck-preview-header">
                                    <h4 class="deck-name" style="color: #E8EEF5; margin: 0 0 4px 0; font-size: 0.9rem;"></h4>
                                    <span class="deck-card-count" style="color: #9fb6cf; font-size: 0.8rem;"></span>
                                </div>
                                <div class="deck-elements" style="margin-top: 8px; font-size: 0.8rem; color: #c8d6e8;"></div>
                            </div>
                        </section>

                        <!-- AI Difficulty Panel -->
                        <section class="ff-panel right-panel">
                            <h2>AI DIFFICULTY</h2>
                            <ul class="ff-list" id="aiDifficultyList">
                                <li class="ff-list-item" data-difficulty="easy" tabindex="0">
                                    <span class="ff-pointer">‚ñ∂</span>
                                    <div>
                                        <strong>EASY</strong>
                                        <br><small style="color: #9fb6cf;">Learning AI - Makes basic mistakes</small>
                                    </div>
                                </li>
                                <li class="ff-list-item" data-difficulty="medium" tabindex="0">
                                    <span class="ff-pointer">‚ñ∂</span>
                                    <div>
                                        <strong>NORMAL</strong>
                                        <br><small style="color: #9fb6cf;">Balanced AI - Solid gameplay</small>
                                    </div>
                                </li>
                                <li class="ff-list-item" data-difficulty="hard" tabindex="0">
                                    <span class="ff-pointer">‚ñ∂</span>
                                    <div>
                                        <strong>HARD</strong>
                                        <br><small style="color: #9fb6cf;">Competitive AI - Advanced tactics</small>
                                    </div>
                                </li>
                            </ul>
                            
                            <!-- Game Options -->
                            <div style="margin-top: 20px; padding-top: 16px; border-top: 1px solid rgba(128, 207, 255, 0.2);">
                                <label style="display: block; color: #c8d6e8; font-size: 0.85rem; margin-bottom: 6px; cursor: pointer;">
                                    <input type="checkbox" id="enableTutorial" checked style="margin-right: 6px;">
                                    Show tutorial hints
                                </label>
                                <label style="display: block; color: #c8d6e8; font-size: 0.85rem; cursor: pointer;">
                                    <input type="checkbox" id="allowUndo" style="margin-right: 6px;">
                                    Allow undo moves
                                </label>
                            </div>
                            
                            <!-- Action Buttons -->
                            <div class="ff-action-row">
                                <button class="ff-button large" id="startPracticeBtn" disabled onclick="startPracticeFromLobby()">
                                    START GAME
                                </button>
                                <button class="ff-button alt" onclick="window.app.switchView('home')">
                                    BACK
                                </button>
                            </div>
                        </section>
                    </main>
                    
                    <footer class="ff-footer">
                        Practice vs AI ‚Ä¢ Hone your skills against computer opponents
                    </footer>
                </div>
                
                <!-- Hidden elements for functionality compatibility -->
                <div style="display: none;">
                    <select id="playerDeckSelect"></select>
                    <select id="aiDifficultySelect"></select>
                    <div id="lobbyPlayerAvatar">‚ö°</div>
                    <div id="lobbyPlayerName">Your Name</div>
                    <div id="lobbyPlayerStats">Games: 0 | Wins: 0</div>
                    <div id="aiAvatar">ü§ñ</div>
                    <div id="aiName">AI Opponent</div>
                    <div id="aiDifficulty">Select Difficulty</div>
                    <div id="playerDeckPreview"></div>
                    <div id="aiDeckInfo"></div>
                </div>
            </section>
        </main>
    </div>

    <!-- Modal Container -->
    <div id="modalContainer"></div>

    <!-- Card Detail Modal -->
    <div id="cardDetailModal" class="card-detail-modal" style="display: none;">
        <div class="card-detail-overlay"></div>
        <div class="card-detail-content">
            <div class="card-detail-image">
                <img id="cardDetailImg" src="" alt="Card Image" class="card-detail-img">
            </div>
            <div class="card-detail-info">
                <h2 id="cardDetailName" class="card-detail-name"></h2>
                <div class="card-detail-stats">
                    <div class="card-detail-stat">
                        <span class="stat-label">Cost:</span>
                        <span id="cardDetailCost" class="stat-value"></span>
                    </div>
                    <div class="card-detail-stat">
                        <span class="stat-label">Element:</span>
                        <span id="cardDetailElement" class="stat-value"></span>
                    </div>
                    <div class="card-detail-stat">
                        <span class="stat-label">Category:</span>
                        <span id="cardDetailCategory" class="stat-value"></span>
                    </div>
                    <div class="card-detail-stat">
                        <span class="stat-label">Type:</span>
                        <span id="cardDetailType" class="stat-value"></span>
                    </div>
                    <div id="cardDetailPowerBlock" class="card-detail-stat" style="display: none;">
                        <span class="stat-label">Power:</span>
                        <span id="cardDetailPower" class="stat-value"></span>
                    </div>
                </div>
                <div class="card-detail-text-section">
                    <h3>Card Text</h3>
                    <div id="cardDetailText" class="card-detail-text"></div>
                </div>
                <div class="card-detail-dismiss-hint">
                    Right-click any card to view details ‚Ä¢ Press any key or click to close
                </div>
            </div>
        </div>
    </div>

    <!-- Zone Overview Modal -->
    <div id="zoneOverviewModal" class="zone-overview-modal" style="display: none;">
        <div class="zone-overview-overlay"></div>
        <div class="zone-overview-content">
            <div class="zone-overview-header">
                <h2 id="zoneOverviewTitle" class="zone-overview-title"></h2>
                <div class="zone-overview-stats">
                    <span id="zoneOverviewCount" class="zone-card-count">0 cards</span>
                    <span id="zoneOverviewCP" class="zone-cp-display" style="display: none;">CP: 0</span>
                </div>
                <button class="zone-overview-close" onclick="hideZoneOverviewModal()">‚úï</button>
            </div>
            <div class="zone-overview-body">
                <div id="zoneOverviewCards" class="zone-overview-cards">
                    <!-- Cards will be populated here -->
                </div>
                <div id="zoneOverviewEmpty" class="zone-overview-empty" style="display: none;">
                    <div class="empty-zone-icon">üì≠</div>
                    <p>This zone is empty</p>
                </div>
            </div>
            <div class="zone-overview-footer">
                <span class="zone-overview-hint">Click on any card for details ‚Ä¢ Press any key or click outside to close</span>
            </div>
        </div>
    </div>

    <!-- Notification Container -->
    <div id="notificationContainer" class="notification-container"></div>

    <!-- Event Log Viewer Modal -->
    <div class="event-log-viewer-modal" id="eventLogViewerModal">
        <div class="event-log-viewer-overlay"></div>
        <div class="event-log-viewer-content">
            <div class="event-log-viewer-header">
                <h2 class="event-log-viewer-title">üìã Game Event Log Viewer</h2>
                <div class="event-log-viewer-controls">
                    <button class="event-log-filter-btn" id="eventLogFilterBtn" title="Filter Events">üîç</button>
                    <button class="event-log-export-btn" id="eventLogExportBtn" title="Export Log">üì§</button>
                    <button class="event-log-viewer-close" id="closeEventLogViewer" title="Close (Esc)">√ó</button>
                </div>
            </div>
            <div class="event-log-viewer-body">
                <div class="event-log-viewer-stats">
                    <span id="eventLogViewerCount">0 events</span>
                    <span>‚Ä¢</span>
                    <span id="eventLogViewerPhase">Loading...</span>
                </div>
                <div class="event-log-viewer-content-area" id="eventLogViewerContent">
                    <!-- Event entries will be populated here -->
                </div>
            </div>
            <div class="event-log-viewer-footer">
                <div class="event-log-viewer-tip">üí° Use filters to narrow down events, or export the full log</div>
            </div>
        </div>
    </div>

    <!-- Mulligan Modal -->
    <div class="mulligan-modal" id="mulliganModal">
        <div class="mulligan-overlay"></div>
        <div class="mulligan-content">
            <div class="mulligan-header">
                <h2 class="mulligan-title">üîÑ Opening Hand - Mulligan Decision</h2>
                <div class="mulligan-subtitle">Review your starting hand and decide if you want to mulligan (shuffle and draw 5 new cards)</div>
            </div>
            <div class="mulligan-body">
                <div class="mulligan-hand-preview" id="mulliganHandPreview">
                    <div class="mulligan-hand-label">Your Opening Hand (5 cards):</div>
                    <div class="mulligan-hand-cards" id="mulliganHandCards">
                        <!-- Current hand cards will be displayed here -->
                    </div>
                </div>
                <div class="mulligan-decision">
                    <div class="mulligan-explanation">
                        <p><strong>Keep this hand?</strong></p>
                        <ul>
                            <li>‚úÖ <strong>Keep:</strong> Start the game with this hand</li>
                            <li>üîÑ <strong>Mulligan:</strong> Shuffle this hand back into your deck and draw 5 new cards</li>
                        </ul>
                        <p class="mulligan-note">üí° <em>You can only mulligan once per game</em></p>
                    </div>
                </div>
            </div>
            <div class="mulligan-footer">
                <button class="btn btn-primary mulligan-keep-btn" id="mulliganKeepBtn" onclick="keepOpeningHand()">
                    ‚úÖ Keep This Hand
                </button>
                <button class="btn btn-secondary mulligan-redraw-btn" id="mulliganRedrawBtn" onclick="mulliganOpeningHand()">
                    üîÑ Mulligan (Redraw)
                </button>
            </div>
        </div>
    </div>

    <!-- JavaScript Modules -->
    <script type="module" src="src/main.js"></script>
    
    <!-- Sidebar Toggle Functions -->
    <script>
        // Update main content margins based on sidebar states
        function updateMainContentMargins() {
            const mainContent = document.querySelector('.main-content-area');
            const searchSidebar = document.getElementById('searchFilterSidebar');
            const deckSidebar = document.getElementById('deckSidebar');
            
            if (!mainContent) return;
            
            const searchCollapsed = searchSidebar.classList.contains('collapsed');
            const deckCollapsed = deckSidebar.classList.contains('collapsed');
            
            // Reset classes
            mainContent.classList.remove('search-collapsed', 'deck-collapsed');
            
            // Add classes based on current state
            if (searchCollapsed) mainContent.classList.add('search-collapsed');
            if (deckCollapsed) mainContent.classList.add('deck-collapsed');
        }
        
        // Update edge bar visibility
        function updateEdgeBars() {
            const leftEdgeBar = document.getElementById('leftEdgeBar');
            const rightEdgeBar = document.getElementById('rightEdgeBar');
            const searchSidebar = document.getElementById('searchFilterSidebar');
            const deckSidebar = document.getElementById('deckSidebar');
            
            // Show left edge bar only when search sidebar is collapsed
            if (leftEdgeBar) {
                leftEdgeBar.style.display = searchSidebar.classList.contains('collapsed') ? 'flex' : 'none';
            }
            
            // Show right edge bar only when deck sidebar is collapsed
            if (rightEdgeBar) {
                rightEdgeBar.style.display = deckSidebar.classList.contains('collapsed') ? 'flex' : 'none';
            }
        }
        
        // Toggle sidebar functions with FF styling
        function toggleSearchSidebar() {
            const filtersSidebar = document.querySelector('.ff-panel.filters');
            if (filtersSidebar) {
                const isVisible = filtersSidebar.style.display !== 'none';
                filtersSidebar.style.display = isVisible ? 'none' : 'block';
                console.log(`üîß Search sidebar ${isVisible ? 'hidden' : 'shown'}`);
                
                // Adjust grid layout for remaining panels
                const gridPanel = document.querySelector('.ff-panel.grid-panel');
                if (gridPanel) {
                    const deckViewVisible = document.querySelector('.ff-panel.deck-view').style.display !== 'none';
                    if (isVisible) {
                        // Filters hidden - expand grid panel
                        gridPanel.style.width = deckViewVisible ? '74%' : '98%';
                    } else {
                        // Filters shown - restore normal width
                        gridPanel.style.width = deckViewVisible ? '56%' : '80%';
                    }
                }
                
                // Update card grid columns to fit available space
                updateCardGridColumns();
            }
        }
        
        function toggleDeckSidebar() {
            const deckViewSidebar = document.querySelector('.ff-panel.deck-view');
            if (deckViewSidebar) {
                const isVisible = deckViewSidebar.style.display !== 'none';
                deckViewSidebar.style.display = isVisible ? 'none' : 'block';
                console.log(`üîß Deck sidebar ${isVisible ? 'hidden' : 'shown'}`);
                
                // Adjust grid layout for remaining panels
                const gridPanel = document.querySelector('.ff-panel.grid-panel');
                if (gridPanel) {
                    const filtersVisible = document.querySelector('.ff-panel.filters').style.display !== 'none';
                    if (isVisible) {
                        // Deck view hidden - expand grid panel significantly
                        gridPanel.style.width = filtersVisible ? '80%' : '98%';
                    } else {
                        // Deck view shown - restore normal width
                        gridPanel.style.width = filtersVisible ? '56%' : '74%';
                    }
                }
                
                // Update card grid columns to fit available space
                updateCardGridColumns();
            }
        }
        
        // Sidebar state restoration disabled - using FF layout
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üîß Old sidebar state restoration disabled');
            // No-op - FF layout doesn't need sidebar state restoration
        });
        
        // Keyboard shortcuts for sidebar toggling
        document.addEventListener('keydown', function(e) {
            // Only activate when in deck builder view and not typing in inputs
            const deckBuilderView = document.getElementById('deck-builderView');
            if (!deckBuilderView || !deckBuilderView.classList.contains('active') || 
                e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                return;
            }
            
            // Sidebar shortcuts for FF layout
            if ((e.ctrlKey || e.metaKey) && e.key === '[') {
                e.preventDefault();
                toggleSearchSidebar();
            }
            if ((e.ctrlKey || e.metaKey) && e.key === ']') {
                e.preventDefault(); 
                toggleDeckSidebar();
            }
        });
        
        // NOTE: toggleFloatingHand() and toggleHand() functions removed - 
        // Hand display is now integrated directly into the game board layout

        // Card hover integration with preview
        function handleCardHover(cardElement, isHovering) {
            const previewArea = document.querySelector('.card-preview-content');
            const previewImage = document.querySelector('.card-preview-image');
            
            if (isHovering) {
                // Add hover effect to preview area
                if (previewArea) previewArea.classList.add('card-hovered');
                if (previewImage) previewImage.classList.add('card-hovered');
                
                // Update preview with card data (if GameBoard component has showCardPreview method)
                if (window.app?.gameBoard?.showCardPreview) {
                    const cardData = cardElement.cardData || {
                        name: cardElement.querySelector('.card-name')?.textContent || 'Unknown Card',
                        cost: cardElement.querySelector('.card-cost')?.textContent || '?',
                        element: 'Unknown'
                    };
                    window.app.gameBoard.showCardPreview(cardData);
                }
            } else {
                // Remove hover effects
                if (previewArea) previewArea.classList.remove('card-hovered');
                if (previewImage) previewImage.classList.remove('card-hovered');
            }
        }

        // NOTE: setupFloatingHandHovers() removed - card hover is now handled by GameBoard.js

        // Call this when hand cards are added to the DOM
        document.addEventListener('DOMContentLoaded', function() {
            // Set up mutation observer to detect when hand cards are added
            const handContent = document.getElementById('playerHandContent');
            if (handContent) {
                const observer = new MutationObserver(function(mutations) {
                    mutations.forEach(function(mutation) {
                        if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
                            // Cards were added, set up hover listeners
                            // NOTE: Card hover setup now handled by GameBoard.js
                        }
                    });
                });
                
                observer.observe(handContent, {
                    childList: true,
                    subtree: true
                });
            }
        });

        // Game menu functions
        function toggleGameMenu() {
            const menu = document.getElementById('gameMenu');
            if (menu.style.display === 'none') {
                menu.style.display = 'block';
                setTimeout(() => menu.classList.add('show'), 10);
            } else {
                menu.classList.remove('show');
                setTimeout(() => menu.style.display = 'none', 200);
            }
        }

        function confirmLeaveGame() {
            if (confirm('Are you sure you want to leave the current game?')) {
                toggleGameMenu();
                window.app?.switchView('home');
            }
        }

        function showGameRules() {
            toggleGameMenu();
            if (window.app && window.app.modal) {
                window.app.modal.open('gameRules');
            }
        }

        // Close game menu when clicking outside
        document.addEventListener('click', function(e) {
            const menu = document.getElementById('gameMenu');
            const menuBtn = document.querySelector('.game-menu-btn');
            
            if (menu && menu.classList.contains('show') && 
                !menu.contains(e.target) && !menuBtn.contains(e.target)) {
                toggleGameMenu();
            }
        });

        // FF Practice Lobby Integration
        let practiceStarfield = null;
        let selectedDeck = null;
        let selectedDifficulty = null;
        
        // Initialize FF Practice Lobby when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            initializePracticeFFInterface();
        });
        
        function initializePracticeFFInterface() {
            // Initialize starfield for practice view
            const practiceCanvas = document.getElementById('practiceStarfield');
            if (practiceCanvas && window.Starfield) {
                practiceStarfield = new window.Starfield('practiceStarfield');
            }
            
            // Set up FF list interactions for deck selection
            setupPracticeDeckList();
            setupAIDifficultyList();
            
            // Monitor practice view visibility for starfield
            const practiceView = document.getElementById('practice-lobbyView');
            if (practiceView) {
                const observer = new MutationObserver((mutations) => {
                    mutations.forEach((mutation) => {
                        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                            const isActive = practiceView.classList.contains('active');
                            if (practiceStarfield) {
                                practiceStarfield.setActive(isActive);
                            }
                            if (isActive) {
                                populatePracticeDeckList();
                            }
                        }
                    });
                });
                observer.observe(practiceView, { attributes: true });
            }
        }
        
        function setupPracticeDeckList() {
            const deckList = document.getElementById('practiceDeckList');
            if (!deckList) return;
            
            deckList.addEventListener('click', function(e) {
                const item = e.target.closest('.ff-list-item');
                if (item && item.dataset.deckId) {
                    selectPracticeDeck(item.dataset.deckId, item);
                }
            });
            
            // Keyboard navigation
            deckList.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' || e.key === ' ') {
                    const selectedItem = deckList.querySelector('.ff-list-item.selected');
                    if (selectedItem && selectedItem.dataset.deckId) {
                        selectPracticeDeck(selectedItem.dataset.deckId, selectedItem);
                    }
                }
            });
        }
        
        function setupAIDifficultyList() {
            const difficultyList = document.getElementById('aiDifficultyList');
            if (!difficultyList) return;
            
            difficultyList.addEventListener('click', function(e) {
                const item = e.target.closest('.ff-list-item');
                if (item && item.dataset.difficulty) {
                    selectAIDifficulty(item.dataset.difficulty, item);
                }
            });
            
            // Keyboard navigation  
            difficultyList.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' || e.key === ' ') {
                    const selectedItem = difficultyList.querySelector('.ff-list-item.selected');
                    if (selectedItem && selectedItem.dataset.difficulty) {
                        selectAIDifficulty(selectedItem.dataset.difficulty, selectedItem);
                    }
                }
            });
        }
        
        function populatePracticeDeckList() {
            const deckList = document.getElementById('practiceDeckList');
            const hiddenSelect = document.getElementById('playerDeckSelect');
            if (!deckList || !window.app?.deckManager) return;
            
            const decks = window.app.deckManager.getDecks();
            deckList.innerHTML = '';
            hiddenSelect.innerHTML = '<option value="">Choose a deck...</option>';
            
            if (decks.length === 0) {
                deckList.innerHTML = '<li class="ff-list-item" style="color: #9fb6cf; cursor: default;"><span style="margin-right: 10px;">üìù</span>No decks available - Create one first!</li>';
                return;
            }
            
            decks.forEach((deck, index) => {
                const item = document.createElement('li');
                item.className = 'ff-list-item';
                item.dataset.deckId = deck.id;
                item.tabIndex = 0;
                if (index === 0) item.classList.add('selected');
                
                item.innerHTML = `
                    <span class="ff-pointer">‚ñ∂</span>
                    <div>
                        <strong>${deck.name}</strong>
                        <br><small style="color: #9fb6cf;">${deck.cards?.length || 0} cards</small>
                    </div>
                `;
                deckList.appendChild(item);
                
                // Also populate hidden select for compatibility
                const option = document.createElement('option');
                option.value = deck.id;
                option.textContent = `${deck.name} (${deck.cards?.length || 0} cards)`;
                hiddenSelect.appendChild(option);
            });
            
            // Auto-select first deck
            if (decks.length > 0) {
                selectPracticeDeck(decks[0].id, deckList.querySelector('.ff-list-item.selected'));
            }
        }
        
        function selectPracticeDeck(deckId, listItem) {
            // Clear previous selections
            document.querySelectorAll('#practiceDeckList .ff-list-item').forEach(item => {
                item.classList.remove('selected');
            });
            
            // Select new item
            if (listItem) {
                listItem.classList.add('selected');
            }
            
            // Update hidden select for compatibility
            const hiddenSelect = document.getElementById('playerDeckSelect');
            if (hiddenSelect) {
                hiddenSelect.value = deckId;
                hiddenSelect.dispatchEvent(new Event('change'));
            }
            
            selectedDeck = deckId;
            showDeckPreview(deckId);
            updateStartButton();
        }
        
        function selectAIDifficulty(difficulty, listItem) {
            // Clear previous selections
            document.querySelectorAll('#aiDifficultyList .ff-list-item').forEach(item => {
                item.classList.remove('selected');
            });
            
            // Select new item
            if (listItem) {
                listItem.classList.add('selected');
            }
            
            // Update hidden select for compatibility
            const hiddenSelect = document.getElementById('aiDifficultySelect');
            if (hiddenSelect) {
                hiddenSelect.value = difficulty;
                hiddenSelect.dispatchEvent(new Event('change'));
            }
            
            selectedDifficulty = difficulty;
            updateStartButton();
        }
        
        function showDeckPreview(deckId) {
            if (!window.app?.deckManager) return;
            
            const deck = window.app.deckManager.getDeck(deckId);
            const preview = document.getElementById('selectedDeckPreview');
            
            if (deck && preview) {
                preview.querySelector('.deck-name').textContent = deck.name;
                preview.querySelector('.deck-card-count').textContent = `${deck.cards?.length || 0} cards`;
                
                // Show elements
                const elements = {};
                deck.cards?.forEach(card => {
                    if (card.element) {
                        elements[card.element] = (elements[card.element] || 0) + 1;
                    }
                });
                
                const elementsText = Object.entries(elements)
                    .map(([element, count]) => `${element}: ${count}`)
                    .join(', ');
                preview.querySelector('.deck-elements').textContent = elementsText || 'No elements';
                
                preview.style.display = 'block';
            }
        }
        
        function updateStartButton() {
            const startBtn = document.getElementById('startPracticeBtn');
            if (startBtn) {
                startBtn.disabled = !selectedDeck || !selectedDifficulty;
            }
        }

        // Filter system now handled by DeckBuilder.js only


        function updateFilterButtonStates(filterType) {
            const container = document.querySelector(`#${filterType}Buttons`);
            if (!container) return;
            
            const buttons = container.querySelectorAll('.filter-btn[data-' + filterType + ']:not([data-' + filterType + '=""])');
            buttons.forEach(btn => {
                const hasActive = btn.classList.contains('active');
                const hasMultiple = activeFilters[filterType].length > 1;
                
                if (hasActive && hasMultiple) {
                    btn.classList.add('multiple-active');
                    btn.classList.remove('active');
                } else if (hasActive) {
                    btn.classList.add('active');
                    btn.classList.remove('multiple-active');
                }
            });
        }

        function applyDeckBuilderFilters() {
            const searchInput = document.getElementById('cardSearch');
            const sortSelect = document.getElementById('sortSelect');
            const cardGrid = document.getElementById('cardGrid');
            const resultsDiv = document.getElementById('filterResults');
            
            if (searchInput) activeFilters.search = searchInput.value.toLowerCase();
            if (sortSelect) activeFilters.sort = sortSelect.value;
            
            console.log('üîç Applying deck builder filters:', activeFilters);
            
            if (!window.app?.cardDatabase) {
                console.error('‚ùå Card database not available');
                return;
            }
            
            if (!cardGrid) {
                console.error('‚ùå Card grid element not found');
                return;
            }
            
            const allCards = window.app.cardDatabase.getAllCards();
            let filteredCards = allCards.filter(card => {
                // Text search
                if (activeFilters.search) {
                    const searchTerm = activeFilters.search;
                    const searchableText = [
                        card.name,
                        card.text || '',
                        card.id,
                        card.abilities || ''
                    ].join(' ').toLowerCase();
                    
                    if (!searchableText.includes(searchTerm)) return false;
                }
                
                // Element filter
                if (activeFilters.element.length > 0) {
                    if (!activeFilters.element.includes(card.element)) return false;
                }
                
                // Type filter
                if (activeFilters.type.length > 0) {
                    if (!activeFilters.type.includes(card.type)) return false;
                }
                
                // Cost filter
                if (activeFilters.cost.length > 0) {
                    const cardCost = parseInt(card.cost) || 0;
                    const matches = activeFilters.cost.some(filterCost => {
                        if (filterCost === '7+') return cardCost >= 7;
                        return cardCost === parseInt(filterCost);
                    });
                    if (!matches) return false;
                }
                
                // Rarity filter
                if (activeFilters.rarity.length > 0) {
                    if (!activeFilters.rarity.includes(card.rarity)) return false;
                }
                
                // Category filter (smart matching for cards with multiple categories)
                if (activeFilters.category.length > 0) {
                    const cardCategories = getCardCategories(card.category);
                    const hasMatchingCategory = cardCategories.some(cat => activeFilters.category.includes(cat));
                    if (!hasMatchingCategory) return false;
                }
                
                // Opus filter
                if (activeFilters.opus.length > 0) {
                    if (!activeFilters.opus.includes(card.opus || card.set)) return false;
                }
                
                return true;
            });
            
            // Sort filtered cards
            filteredCards = sortCards(filteredCards, activeFilters.sort);
            
            // Update display
            renderFilteredCards(filteredCards);
            
            // Update results counter
            if (resultsDiv) {
                resultsDiv.textContent = `Showing ${filteredCards.length} of ${allCards.length} cards`;
            }
        }

        function sortCards(cards, sortType) {
            return cards.sort((a, b) => {
                switch (sortType) {
                    case 'name-desc':
                        return b.name.localeCompare(a.name);
                    case 'cost-asc':
                        return (parseInt(a.cost) || 0) - (parseInt(b.cost) || 0);
                    case 'cost-desc':
                        return (parseInt(b.cost) || 0) - (parseInt(a.cost) || 0);
                    case 'id-asc':
                        return a.id.localeCompare(b.id);
                    case 'name-asc':
                    default:
                        return a.name.localeCompare(b.name);
                }
            });
        }

        // Helper function for smart category filtering
        function getCardCategories(categoryString) {
            if (!categoryString) return ['Special'];
            
            // Split dual categories on &middot; separator or other common separators
            const separators = ['&middot;', '‚Ä¢', '¬∑', ' / ', '/'];
            let categories = [categoryString.trim()];
            
            for (const sep of separators) {
                if (categoryString.includes(sep)) {
                    categories = categoryString.split(sep).map(cat => cat.trim());
                    break;
                }
            }
            
            // Clean up and normalize category names
            return categories.filter(cat => cat && cat.length > 0).map(cat => {
                // Remove HTML entities and normalize
                return cat.replace(/&middot;/g, '').replace(/&nbsp;/g, ' ').trim();
            });
        }

        // New dropdown handler functions
        function handleOpusSelectChange(select) {
            const value = select.value;
            
            // Update both our filter system and the DeckBuilder.js system
            activeFilters.opus = value ? [value] : [];
            
            // Always apply our filter system first
            console.log(`üéØ Opus filter changed to: ${value || 'All'}`);
            applyDeckBuilderFilters();
            
            // Also sync with DeckBuilder.js if it exists
            if (window.app?.deckBuilder) {
                window.app.deckBuilder.opusFilter = value ? [value] : [];
            }
        }

        function handleCostSelectChange(select) {
            const value = select.value;
            
            // Update both our filter system and the DeckBuilder.js system
            activeFilters.cost = value ? [value] : [];
            
            // Always apply our filter system first
            console.log(`üí∞ Cost filter changed to: ${value || 'All'}`);
            applyDeckBuilderFilters();
            
            // Also sync with DeckBuilder.js if it exists
            if (window.app?.deckBuilder) {
                window.app.deckBuilder.costFilter = value ? [value] : [];
            }
        }

        function handleCategorySelectChange(select) {
            const value = select.value;
            console.log(`üè∑Ô∏è Category filter changed to: "${value || 'All'}"`);            
            if (window.app?.deckBuilder?.setCategoryFilter) {
                window.app.deckBuilder.setCategoryFilter(value);
            }
        }



        function clearAllDeckBuilderFilters() {
            console.log('üîß Clearing all deck builder filters');
            
            // Clear HTML inputs
            const searchInput = document.getElementById('cardSearch');
            if (searchInput) searchInput.value = '';
            
            const sortSelect = document.getElementById('sortSelect');
            if (sortSelect) sortSelect.value = 'name-asc';
            
            const opusSelect = document.getElementById('opusSelect');
            if (opusSelect) opusSelect.value = '';
            
            const costSelect = document.getElementById('costSelect');
            if (costSelect) costSelect.value = '';
            
            const categorySelect = document.getElementById('categorySelect');
            if (categorySelect) categorySelect.value = '';
            
            // Clear DeckBuilder.js filters
            if (window.app?.deckBuilder) {
                window.app.deckBuilder.clearAllFilters();
                window.app.deckBuilder.refreshCardDisplay();
            }
        }


        // Card Browser Functions (Keep existing for browser view)
        function clearBrowserFilters() {
            const elementFilter = document.getElementById('browserElementFilter');
            const costFilter = document.getElementById('browserCostFilter');
            const typeFilter = document.getElementById('browserTypeFilter');
            const costValue = document.getElementById('costValue');
            
            if (elementFilter) elementFilter.value = '';
            if (costFilter) {
                costFilter.value = '4';
                if (costValue) costValue.textContent = 'All';
            }
            if (typeFilter) typeFilter.value = '';
            
            console.log('üÉè Card Browser filters cleared');
        }
        
        function previewCard(cardId) {
            console.log('üîç Previewing card:', cardId);
            // This would show card details - for now just log
            if (window.app && window.app.cardDatabase) {
                const card = window.app.cardDatabase.getCard(cardId);
                if (card) {
                    console.log('üìÑ Card details:', card.name, card);
                    // Could open a modal or update a preview panel here
                } else {
                    console.warn('Card not found:', cardId);
                }
            }
        }

        // FF Sound Settings Functions
        function toggleFFSounds(enabled) {
            console.log('üîä FF Sounds', enabled ? 'enabled' : 'disabled');
            
            if (window.ffSounds || window.app?.soundEffects) {
                const soundSystem = window.ffSounds || window.app.soundEffects;
                if (enabled) {
                    soundSystem.enable();
                    soundSystem.attachToExistingUI(); // Add sounds to current UI elements
                } else {
                    soundSystem.disable();
                }
            }
            
            // Save preference to localStorage
            localStorage.setItem('ffSoundsEnabled', enabled.toString());
        }
        
        function setSoundVolume(volume) {
            const volumeDisplay = document.getElementById('volumeDisplay');
            if (volumeDisplay) {
                volumeDisplay.textContent = volume + '%';
            }
            
            if (window.ffSounds || window.app?.soundEffects) {
                const soundSystem = window.ffSounds || window.app.soundEffects;
                soundSystem.setVolume(volume / 100);
            }
            
            // Save preference to localStorage
            localStorage.setItem('ffSoundVolume', volume.toString());
            
            console.log('üîä FF Sound volume set to', volume + '%');
        }
        
        // Navigation Functions
        function goBackToMenu() {
            if (window.app) {
                window.app.switchView('home');
                console.log('üè† Returned to main menu');
            }
        }

        // Working deck creation with proper card rendering
        function testNewDeck() {
            console.log('üß™ Creating new deck with full card features...');
            
            // Step 1: Show deck editor
            const deckManager = document.getElementById('deckManager');
            const deckEditor = document.getElementById('deckEditor');
            
            if (deckManager && deckEditor) {
                deckManager.style.display = 'none';
                deckEditor.style.display = 'block';
                
                // Step 1.5: Start debugging
                debugCardGrid();
                
                // Step 2: Load cards with full features
                loadCardsWithFeatures();
                
                console.log('‚úÖ Deck editor opened with full card features');
            } else {
                alert('Could not find deck elements');
            }
        }
        
        // Load cards with all the proper features
        function loadCardsWithFeatures() {
            console.log('üîç DEBUG: loadCardsWithFeatures() called');
            
            const ffCardGrid = document.getElementById('cardGrid');
            console.log('üîç DEBUG: cardGrid element:', ffCardGrid);
            console.log('üîç DEBUG: cardGrid current innerHTML length:', ffCardGrid?.innerHTML?.length);
            console.log('üîç DEBUG: cardGrid current children count:', ffCardGrid?.children?.length);
            console.log('üîç DEBUG: cardGrid current classes:', ffCardGrid?.className);
            
            if (!ffCardGrid || !window.app?.cardDatabase) {
                console.warn('‚ö†Ô∏è Card grid or database not available');
                return;
            }
            
            console.log('üÉè Loading cards with full features...');
            
            // Initialize filters first
            initializeDeckBuilderFilters();
            
            // Apply initial filter (show all cards)
            applyDeckBuilderFilters();
            
            console.log(`‚úÖ Loaded cards with full features and filters`);
        }
        
        // Removed populateCardGridManually() - cards populated by loadCardsWithFeatures() only
        
        // Card preview functions
        function showCardPreview(element, cardId) {
            if (!window.app?.cardDatabase) return;
            
            const card = window.app.cardDatabase.getCard(cardId);
            if (!card) return;
            
            // Create or get preview element
            let preview = document.getElementById('cardPreviewPopup');
            if (!preview) {
                preview = document.createElement('div');
                preview.id = 'cardPreviewPopup';
                preview.className = 'card-preview-popup';
                document.body.appendChild(preview);
            }
            
            const imageUrl = window.app.cardDatabase.getCardImageUrl ? 
                window.app.cardDatabase.getCardImageUrl(card.id) : 
                (card.image || `/assets/images/cards/${card.id}.jpg`);
            
            preview.innerHTML = `
                <div class="preview-image">
                    <img src="${imageUrl}" alt="${card.name}" onerror="this.src='/assets/images/card-back.jpg';">
                </div>
                <div class="preview-info">
                    <h3>${card.name}</h3>
                    <div class="preview-details">
                        ${card.cost ? `<span>Cost: ${card.cost}</span>` : ''}
                        ${card.element ? `<span>Element: ${card.element}</span>` : ''}
                        ${card.type ? `<span>Type: ${card.type}</span>` : ''}
                        ${card.power ? `<span>Power: ${card.power}</span>` : ''}
                    </div>
                    ${card.text ? `<div class="preview-text">${card.text}</div>` : ''}
                </div>
            `;
            
            // Position preview near the hovered card
            const rect = element.getBoundingClientRect();
            preview.style.left = (rect.right + 10) + 'px';
            preview.style.top = rect.top + 'px';
            preview.style.display = 'block';
        }
        
        function hideCardPreview() {
            const preview = document.getElementById('cardPreviewPopup');
            if (preview) {
                preview.style.display = 'none';
            }
        }
        
        // Function to add card to deck
        function addCardToDeck(cardId) {
            console.log('üÉè Adding card to deck:', cardId);
            
            if (!window.app?.cardDatabase) return;
            const card = window.app.cardDatabase.getCard(cardId);
            if (!card) return;
            
            // Get current deck list
            const currentDeckList = document.getElementById('currentDeckList');
            const deckCardCount = document.getElementById('deckCardCount');
            
            if (currentDeckList && deckCardCount) {
                // Simple implementation - just add to visual list
                const existingCard = currentDeckList.querySelector(`[data-card-id="${cardId}"]`);
                if (existingCard) {
                    // Increment count if card already exists
                    const countSpan = existingCard.querySelector('.card-count');
                    const currentCount = parseInt(countSpan.textContent.replace('x', '')) || 1;
                    if (currentCount < 3) { // Max 3 copies
                        countSpan.textContent = `x${currentCount + 1}`;
                    }
                } else {
                    // Add new card
                    const cardElement = document.createElement('div');
                    cardElement.className = 'deck-card-item';
                    cardElement.setAttribute('data-card-id', cardId);
                    cardElement.innerHTML = `
                        <span class="card-name">${card.name}</span>
                        <span class="card-count">x1</span>
                    `;
                    currentDeckList.appendChild(cardElement);
                }
                
                // Update deck count
                const totalCards = Array.from(currentDeckList.querySelectorAll('.card-count'))
                    .reduce((total, countElement) => {
                        return total + (parseInt(countElement.textContent.replace('x', '')) || 0);
                    }, 0);
                
                deckCardCount.textContent = `${totalCards}/50`;
                
                console.log(`‚úÖ Added ${card.name} to deck. Total cards: ${totalCards}`);
            }
        }

        // Deck Builder Functions - Minimal approach to avoid freezing
        function createNewDeckFF() {
            console.log('üé¥ Creating new deck...');
            
            // Super simple approach - just show/hide elements
            const deckManager = document.getElementById('deckManager');
            const deckEditor = document.getElementById('deckEditor');
            
            if (deckManager && deckEditor) {
                deckManager.style.display = 'none';
                deckEditor.style.display = 'block';
                
                // Set deck name
                const deckNameInput = document.getElementById('deckName');
                if (deckNameInput) {
                    deckNameInput.value = 'New Deck';
                }
                
                console.log('‚úÖ Deck editor shown');
            } else {
                alert('Deck editor not found. Please refresh the page.');
            }
        }

        function exitDeckEditor() {
            console.log('üîô Exiting deck editor...');
            
            // Safe approach - directly hide/show elements
            try {
                const deckManager = document.getElementById('deckManager');
                const deckEditor = document.getElementById('deckEditor');
                
                if (deckManager && deckEditor) {
                    // Show deck manager, hide deck editor
                    deckManager.style.display = 'block';
                    deckEditor.style.display = 'none';
                    
                    console.log('‚úÖ Returned to deck manager');
                } else {
                    throw new Error('Deck manager elements not found');
                }
            } catch (error) {
                console.error('‚ùå Error exiting deck editor:', error);
                // Fallback - try the original method
                if (window.app && window.app.deckBuilder) {
                    window.app.deckBuilder.exitDeckEditor();
                }
            }
        }

        function saveDeckFF() {
            console.log('üíæ Saving deck...');
            if (window.app && window.app.deckBuilder) {
                window.app.deckBuilder.saveDeck();
            } else {
                alert('Unable to save deck. Please try again.');
            }
        }

        function clearDeckFF() {
            console.log('üóëÔ∏è Clearing deck...');
            if (confirm('Are you sure you want to clear the current deck? This cannot be undone.')) {
                if (window.app && window.app.deckBuilder) {
                    window.app.deckBuilder.clearDeck();
                    console.log('‚úÖ Deck cleared successfully');
                } else {
                    alert('Unable to clear deck. Please try again.');
                }
            }
        }

        // DeckBuilder FF Integration - Simplified approach to avoid freezing
        function setupDeckBuilderIntegration() {
            console.log('üîó DeckBuilder FF integration disabled temporarily to prevent freezing');
            
            // Card population handled by loadCardsWithFeatures() only
        }

        // DEBUG: Monitor any changes to the cardGrid
        function debugCardGrid() {
            const cardGrid = document.getElementById('cardGrid');
            if (!cardGrid) {
                console.log('üîç DEBUG: No cardGrid found to monitor');
                return;
            }
            
            console.log('üîç DEBUG: Setting up cardGrid monitoring...');
            
            // Monitor DOM mutations
            const observer = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                    console.log('üîç DEBUG: CardGrid MUTATION detected:', mutation.type);
                    console.log('üîç DEBUG: Added nodes:', mutation.addedNodes.length);
                    console.log('üîç DEBUG: Removed nodes:', mutation.removedNodes.length);
                    console.log('üîç DEBUG: Current children count:', cardGrid.children.length);
                    
                    if (mutation.addedNodes.length > 0) {
                        Array.from(mutation.addedNodes).forEach((node, i) => {
                            if (node.nodeType === 1) { // Element node
                                console.log(`üîç DEBUG: Added element ${i}:`, node.className, node.tagName);
                            }
                        });
                    }
                });
            });
            
            observer.observe(cardGrid, {
                childList: true,
                subtree: true,
                attributes: false
            });
            
            console.log('üîç DEBUG: CardGrid monitoring active');
        }

        // Load sound settings and setup keyboard shortcuts on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Restore sound settings
            const soundsEnabled = localStorage.getItem('ffSoundsEnabled') === 'true';
            const soundVolume = localStorage.getItem('ffSoundVolume') || '30';
            
            const enableCheckbox = document.getElementById('enableFFSounds');
            const volumeSlider = document.getElementById('soundVolume');
            const volumeDisplay = document.getElementById('volumeDisplay');
            
            if (enableCheckbox) enableCheckbox.checked = soundsEnabled;
            if (volumeSlider) volumeSlider.value = soundVolume;
            if (volumeDisplay) volumeDisplay.textContent = soundVolume + '%';
            
            console.log('üîä Sound settings loaded:', {enabled: soundsEnabled, volume: soundVolume + '%'});
            
            // DeckBuilder integration temporarily disabled for troubleshooting
            // setupDeckBuilderIntegration();
            
            // Keyboard shortcuts temporarily disabled to troubleshoot freezing
            console.log('‚å®Ô∏è  Keyboard shortcuts disabled for troubleshooting');
        });

        // Simplified Practice Lobby Functions - Main logic now in PracticeLobby.js component
        function startPracticeFromLobby() {
            if (window.app?.practiceLobby) {
                window.app.practiceLobby.startPracticeGame().catch(error => {
                    console.error('Failed to start practice game:', error);
                    alert('Failed to start practice game: ' + error.message);
                });
            } else {
                alert('Practice lobby not ready. Please wait and try again.');
            }
        }

        // Card Detail Modal System
        let currentHoveredCard = null;
        let cardDetailModalOpen = false;

        // Track currently hovered card
        function setCurrentHoveredCard(cardElement) {
            currentHoveredCard = cardElement;
        }

        function clearCurrentHoveredCard() {
            currentHoveredCard = null;
        }

        // Show detailed card modal
        function showCardDetailModal(cardData) {
            const modal = document.getElementById('cardDetailModal');
            const img = document.getElementById('cardDetailImg');
            const name = document.getElementById('cardDetailName');
            const cost = document.getElementById('cardDetailCost');
            const element = document.getElementById('cardDetailElement');
            const category = document.getElementById('cardDetailCategory');
            const type = document.getElementById('cardDetailType');
            const power = document.getElementById('cardDetailPower');
            const powerBlock = document.getElementById('cardDetailPowerBlock');
            const text = document.getElementById('cardDetailText');

            if (!modal || !cardData) return;

            // Populate modal with card data
            if (img && cardData.imageUrl) {
                img.src = cardData.imageUrl;
                img.alt = cardData.name || 'Card Image';
            }
            
            if (name) name.textContent = cardData.name || 'Unknown Card';
            if (cost) cost.textContent = cardData.cost || '?';
            if (element) element.textContent = cardData.element || 'None';
            if (category) category.textContent = cardData.category || 'Unknown';
            if (type) type.textContent = cardData.type || 'Unknown';
            
            // Show/hide power for forwards and monsters
            if (powerBlock && power) {
                if (cardData.power && (cardData.type === 'forward' || cardData.type === 'monster')) {
                    power.textContent = cardData.power;
                    powerBlock.style.display = 'flex';
                } else {
                    powerBlock.style.display = 'none';
                }
            }

            // Populate and highlight card text
            if (text && cardData.text) {
                text.innerHTML = highlightCardText(cardData.text);
            } else if (text) {
                text.textContent = 'No card text available.';
            }

            // Show modal
            modal.style.display = 'flex';
            cardDetailModalOpen = true;

            // Prevent scroll
            document.body.style.overflow = 'hidden';
        }

        // Hide card detail modal
        function hideCardDetailModal() {
            const modal = document.getElementById('cardDetailModal');
            if (modal) {
                modal.style.display = 'none';
                cardDetailModalOpen = false;
                document.body.style.overflow = '';
            }
        }

        // Highlight keywords and abilities in card text
        function highlightCardText(text) {
            if (!text) return '';
            
            // Common FFTCG keywords to highlight
            const keywords = [
                'Haste', 'First Strike', 'Brave', 'Vigilance', 'Multicast', 'Ex Burst',
                'Dull', 'Break', 'Search', 'Draw', 'Discard', 'Activate', 'Auto',
                'Field', 'Hand', 'Damage Zone', 'Break Zone', 'EX Burst', 'S Ability',
                'Special Ability', 'Action Ability', 'Backup', 'Forward', 'Summon',
                'Monster', 'Choose', 'Pay', 'Cast', 'Play', 'Remove', 'Return',
                'Crystal Points', 'CP', 'Power', 'Job', 'Category'
            ];

            let highlightedText = text;

            // Highlight keywords
            keywords.forEach(keyword => {
                const regex = new RegExp(`\\b(${keyword})\\b`, 'gi');
                highlightedText = highlightedText.replace(regex, '<span class="keyword">$1</span>');
            });

            // Highlight ability names (text in brackets)
            highlightedText = highlightedText.replace(/\[([^\]]+)\]/g, '<span class="ability-name">[$1]</span>');

            // Highlight cost references (numbers in parentheses for costs)
            highlightedText = highlightedText.replace(/\((\d+)\)/g, '<span class="cost-reference">($1)</span>');

            return highlightedText;
        }

        // Keyboard event handler for closing modal
        document.addEventListener('keydown', function(e) {
            // Only work in game view
            if (!document.getElementById('gameView').classList.contains('active')) {
                return;
            }

            // Hide modal on any key press when modal is open
            if (cardDetailModalOpen) {
                e.preventDefault();
                hideCardDetailModal();
            }
        });

        // Right-click handler for showing card detail modal
        document.addEventListener('contextmenu', function(e) {
            // Only work in game view
            if (!document.getElementById('gameView').classList.contains('active')) {
                return;
            }

            const cardElement = e.target.closest('.game-card');
            if (cardElement && !cardDetailModalOpen) {
                e.preventDefault(); // Prevent default context menu
                
                // Get card data from the clicked card element
                const cardData = extractCardDataFromElement(cardElement);
                if (cardData) {
                    showCardDetailModal(cardData);
                }
            }
        });

        // Hide modal on left click when open
        document.addEventListener('click', function(e) {
            if (cardDetailModalOpen) {
                hideCardDetailModal();
            }
        });

        // Extract card data from a card element
        function extractCardDataFromElement(cardElement) {
            if (!cardElement) return null;

            // Get card ID from dataset
            const cardId = cardElement.dataset.cardId;
            
            // Try to get card data from the game board's card database
            let card = null;
            if (cardId && window.app?.gameBoard?.cardDatabase) {
                card = window.app.gameBoard.cardDatabase.getCard(cardId);
            }
            
            // If we have card data from database, use it; otherwise fall back to DOM parsing
            if (card) {
                return {
                    name: card.name || 'Unknown Card',
                    cost: card.cost || '?',
                    element: card.element || 'None',
                    category: card.category || card.categories?.[0] || 'Unknown',
                    type: card.type || 'Unknown',
                    power: card.power || '',
                    text: card.text || card.abilities?.join('\n') || 'No card text available.',
                    imageUrl: cardElement.querySelector('.card-real-image')?.src || card.image || ''
                };
            } else {
                // Fallback to DOM parsing if database lookup fails
                return {
                    name: cardElement.querySelector('.card-name')?.textContent || 'Unknown Card',
                    cost: cardElement.querySelector('.card-cost')?.textContent || '?',
                    element: cardElement.className.match(/element-(\w+)/)?.[1] || 'None',
                    category: 'Unknown',
                    type: 'Unknown',
                    power: '',
                    text: 'No card text available.',
                    imageUrl: cardElement.querySelector('.card-real-image')?.src || ''
                };
            }
        }

        // Set up card hover tracking for the modal system
        function setupCardHoverTracking() {
            // Set up hover tracking for all game cards
            document.addEventListener('mouseover', function(e) {
                const cardElement = e.target.closest('.game-card');
                if (cardElement && document.getElementById('gameView').classList.contains('active')) {
                    setCurrentHoveredCard(cardElement);
                }
            });

            document.addEventListener('mouseout', function(e) {
                const cardElement = e.target.closest('.game-card');
                if (cardElement && document.getElementById('gameView').classList.contains('active')) {
                    // Only clear if we're leaving the specific card
                    if (!cardElement.contains(e.relatedTarget)) {
                        clearCurrentHoveredCard();
                    }
                }
            });
        }

        // Zone Overview Modal System
        let zoneOverviewModalOpen = false;

        // Open unified zone modal for graveyard and removed cards
        function openUnifiedZoneModal(player) {
            const modal = document.getElementById('zoneOverviewModal');
            const title = document.getElementById('zoneOverviewTitle');
            const content = document.getElementById('zoneOverviewContent');
            
            if (!modal || !title || !content) {
                console.error('Zone modal elements not found');
                return;
            }
            
            // Set title
            title.textContent = `${player === 'player' ? 'Your' : 'Opponent'} Graveyard & Removed Cards`;
            
            // Create tabbed interface
            content.innerHTML = `
                <div class="zone-tabs">
                    <button class="zone-tab active" onclick="showZoneTab('graveyard', '${player}')">
                        <span class="tab-icon">ü™¶</span>
                        <span class="tab-text">Graveyard</span>
                        <span class="tab-count" id="${player}GraveyardTabCount">0</span>
                    </button>
                    <button class="zone-tab" onclick="showZoneTab('removed', '${player}')">
                        <span class="tab-icon">üö´</span>
                        <span class="tab-text">Removed</span>
                        <span class="tab-count" id="${player}RemovedTabCount">0</span>
                    </button>
                </div>
                <div class="zone-tab-content">
                    <div id="graveyardContent" class="tab-panel active">
                        <div class="zone-empty">No cards in graveyard</div>
                    </div>
                    <div id="removedContent" class="tab-panel">
                        <div class="zone-empty">No cards removed from game</div>
                    </div>
                </div>
            `;
            
            // Load initial content
            showZoneTab('graveyard', player);
            
            // Show modal
            modal.style.display = 'flex';
            zoneOverviewModalOpen = true;
        }
        
        // Show specific tab in unified zone modal
        function showZoneTab(tabType, player) {
            // Update tab buttons
            const tabs = document.querySelectorAll('.zone-tab');
            tabs.forEach(tab => tab.classList.remove('active'));
            event?.target.closest('.zone-tab')?.classList.add('active');
            
            // Update tab panels
            const panels = document.querySelectorAll('.tab-panel');
            panels.forEach(panel => panel.classList.remove('active'));
            document.getElementById(`${tabType}Content`).classList.add('active');
            
            // Load content based on tab type
            const content = document.getElementById(`${tabType}Content`);
            if (tabType === 'graveyard') {
                loadGraveyardContent(content, player);
            } else if (tabType === 'removed') {
                loadRemovedContent(content, player);
            }
        }
        
        // Load graveyard content
        function loadGraveyardContent(container, player) {
            // This would load from the game board's break zone
            if (window.app?.gameBoard?.breakZones) {
                const cards = window.app.gameBoard.breakZones[player] || [];
                if (cards.length === 0) {
                    container.innerHTML = '<div class="zone-empty">No cards in graveyard</div>';
                } else {
                    container.innerHTML = cards.map(card => 
                        `<div class="zone-card" onclick="viewCard('${card.id}')">
                            <div class="card-mini">${card.name || 'Unknown Card'}</div>
                        </div>`
                    ).join('');
                }
                
                // Update tab count
                const tabCount = document.getElementById(`${player}GraveyardTabCount`);
                if (tabCount) tabCount.textContent = cards.length;
            } else {
                container.innerHTML = '<div class="zone-empty">No cards in graveyard</div>';
            }
        }
        
        // Load removed content
        function loadRemovedContent(container, player) {
            // This would load from the game board's removed zone
            if (window.app?.gameBoard?.removedZones) {
                const cards = window.app.gameBoard.removedZones[player] || [];
                if (cards.length === 0) {
                    container.innerHTML = '<div class="zone-empty">No cards removed from game</div>';
                } else {
                    container.innerHTML = cards.map(card => 
                        `<div class="zone-card" onclick="viewCard('${card.id}')">
                            <div class="card-mini">${card.name || 'Unknown Card'}</div>
                        </div>`
                    ).join('');
                }
                
                // Update tab count
                const tabCount = document.getElementById(`${player}RemovedTabCount`);
                if (tabCount) tabCount.textContent = cards.length;
            } else {
                container.innerHTML = '<div class="zone-empty">No cards removed from game</div>';
            }
        }

        // Legacy function for backward compatibility
        function openZoneModal(zoneType) {
            const zoneNames = {
                'player-damage': { 
                    name: 'playerDamageContent', 
                    title: 'Your Damage Zone',
                    type: 'player-damage'
                },
                'player-break': { 
                    name: 'playerBreakContent', 
                    title: 'Your Break Zone',
                    type: 'player-break'
                },
                'opponent-damage': { 
                    name: 'opponentDamageContent', 
                    title: 'Opponent Damage Zone',
                    type: 'opponent-damage'
                },
                'opponent-break': { 
                    name: 'opponentBreakContent', 
                    title: 'Opponent Break Zone',
                    type: 'opponent-break'
                },
                'player-removed': { 
                    name: 'playerRemovedContent', 
                    title: 'Your Removed Cards',
                    type: 'player-removed'
                },
                'opponent-removed': { 
                    name: 'opponentRemovedContent', 
                    title: 'Opponent Removed Cards',
                    type: 'opponent-removed'
                }
            };
            
            const zoneInfo = zoneNames[zoneType];
            if (zoneInfo) {
                showZoneOverviewModal(zoneInfo.name, zoneInfo.type);
            }
        }

        // Show zone overview modal
        function showZoneOverviewModal(zoneName, zoneType) {
            const modal = document.getElementById('zoneOverviewModal');
            const title = document.getElementById('zoneOverviewTitle');
            const count = document.getElementById('zoneOverviewCount');
            const cpDisplay = document.getElementById('zoneOverviewCP');
            const cardsContainer = document.getElementById('zoneOverviewCards');
            const emptyMessage = document.getElementById('zoneOverviewEmpty');

            if (!modal) return;

            // Get zone element and cards
            const zoneElement = getZoneElement(zoneName);
            if (!zoneElement) return;

            const cards = Array.from(zoneElement.querySelectorAll('.game-card'));
            
            // Set title
            const formattedZoneName = formatZoneName(zoneName);
            if (title) title.textContent = formattedZoneName;

            // Set card count
            if (count) {
                const cardCount = cards.length;
                count.textContent = `${cardCount} card${cardCount !== 1 ? 's' : ''}`;
            }

            // Show/hide CP display for backup zones
            if (cpDisplay) {
                // CP display is handled by the modular CP system
                cpDisplay.style.display = 'none';
            }

            // Populate cards
            if (cardsContainer && emptyMessage) {
                if (cards.length === 0) {
                    cardsContainer.style.display = 'none';
                    emptyMessage.style.display = 'flex';
                } else {
                    cardsContainer.style.display = 'grid';
                    emptyMessage.style.display = 'none';
                    cardsContainer.innerHTML = '';

                    cards.forEach((cardElement, index) => {
                        const cardData = extractCardDataFromElement(cardElement);
                        if (cardData) {
                            const zoneCard = createZoneOverviewCard(cardData, cardElement);
                            cardsContainer.appendChild(zoneCard);
                        }
                    });
                }
            }

            // Show modal
            modal.style.display = 'flex';
            zoneOverviewModalOpen = true;
            document.body.style.overflow = 'hidden';
        }

        // Hide zone overview modal
        function hideZoneOverviewModal() {
            const modal = document.getElementById('zoneOverviewModal');
            if (modal) {
                modal.style.display = 'none';
                zoneOverviewModalOpen = false;
                document.body.style.overflow = '';
            }
        }

        // Create a card element for the zone overview
        function createZoneOverviewCard(cardData, originalElement) {
            const card = document.createElement('div');
            card.className = 'zone-overview-card';
            
            // Check if card is tapped
            if (originalElement && originalElement.classList.contains('tapped')) {
                card.classList.add('tapped');
            }

            const powerDisplay = (cardData.power && (cardData.type === 'forward' || cardData.type === 'monster')) 
                ? `<span class="zone-card-power">${cardData.power}</span>` 
                : '';

            card.innerHTML = `
                <div class="zone-card-name">${cardData.name}</div>
                <div class="zone-card-details">
                    <span class="zone-card-cost">${cardData.cost}</span>
                    <span class="zone-card-element element-${cardData.element}">${cardData.element}</span>
                </div>
                <div class="zone-card-details">
                    <span class="zone-card-type">${cardData.type}</span>
                    ${powerDisplay}
                </div>
            `;

            // Add click handler to show card detail modal
            card.addEventListener('click', (e) => {
                e.stopPropagation();
                hideZoneOverviewModal();
                setTimeout(() => showCardDetailModal(cardData), 100);
            });

            // Store card data on element for potential future use
            card.cardData = cardData;

            return card;
        }

        // Get zone element by zone name
        function getZoneElement(zoneName) {
            const zoneMap = {
                'playerBackups': 'playerBackupsContent',
                'playerSummons': 'playerSummonsContent', 
                'playerDamage': 'playerDamageContent',
                'playerBreakContent': 'playerBreakContent',
                'opponentBackups': 'opponentBackupsContent',
                'opponentSummons': 'opponentSummonsContent',
                'opponentDamage': 'opponentDamageContent',
                'opponentBreakContent': 'opponentBreakContent'
            };

            const elementId = zoneMap[zoneName];
            return elementId ? document.getElementById(elementId) : null;
        }

        // Format zone name for display
        function formatZoneName(zoneName) {
            const nameMap = {
                'playerBackups': 'Your Backup Zone',
                'playerSummons': 'Your Summon Zone',
                'playerDamage': 'Your Damage Zone',
                'playerBreakContent': 'Your Break Zone',
                'opponentBackups': 'Opponent Backup Zone',
                'opponentSummons': 'Opponent Summon Zone',
                'opponentDamage': 'Opponent Damage Zone',
                'opponentBreakContent': 'Opponent Break Zone'
            };

            return nameMap[zoneName] || zoneName;
        }

        // Set up zone click handlers
        function setupZoneClickHandlers() {
            // Define zones that should be clickable (excluding field zones which no longer have headers)
            const clickableZones = [
                'playerDamage', 'opponentDamage'
            ];

            clickableZones.forEach(zoneName => {
                const zoneElement = document.getElementById(zoneName);
                if (zoneElement) {
                    const zoneHeader = zoneElement.querySelector('.zone-header');
                    if (zoneHeader) {
                        // Add clickable styling
                        zoneHeader.style.cursor = 'pointer';
                        zoneHeader.title = 'Click to view zone contents';
                        
                        // Add click handler
                        zoneHeader.addEventListener('click', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            if (document.getElementById('gameView').classList.contains('active')) {
                                showZoneOverviewModal(zoneName, 'zone');
                            }
                        });

                        // Add hover effect
                        zoneHeader.addEventListener('mouseenter', () => {
                            zoneHeader.style.background = 'linear-gradient(90deg, transparent 0%, rgba(255, 215, 0, 0.15) 50%, transparent 100%)';
                        });

                        zoneHeader.addEventListener('mouseleave', () => {
                            zoneHeader.style.background = 'linear-gradient(90deg, transparent 0%, rgba(255, 215, 0, 0.1) 50%, transparent 100%)';
                        });
                    }
                }
            });
        }

        // Handle zone overview modal events
        document.addEventListener('keydown', function(e) {
            // Close zone overview modal on any key press
            if (zoneOverviewModalOpen) {
                e.preventDefault();
                hideZoneOverviewModal();
            }
        });

        document.addEventListener('click', function(e) {
            // Close zone overview modal when clicking overlay
            if (zoneOverviewModalOpen && e.target.classList.contains('zone-overview-overlay')) {
                hideZoneOverviewModal();
            }
        });

        // Handle dynamic action button (Next Phase / End Turn)
        function handleDynamicAction() {
            if (window.app && window.app.gameEngine) {
                window.app.gameEngine.nextPhase();
            } else {
                console.error('Game Engine not available');
                window.showNotification('Game not active', 'error');
            }
        }

        // Open damage zone modal to view life points
        function openDamageZoneModal(player) {
            if (window.app && window.app.gameBoard) {
                window.app.gameBoard.showDamageZoneModal(player);
            } else {
                console.error('GameBoard not available');
                window.showNotification('Cannot view damage zone - game not active', 'error');
            }
        }

        // Toggle event log panel
        let eventLogOpen = false;
        function toggleEventLog() {
            const eventLog = document.getElementById('rightEventLog');
            const panel = document.getElementById('eventLogPanel');
            const toggle = document.getElementById('eventLogToggle');
            
            eventLogOpen = !eventLogOpen;
            
            if (eventLogOpen) {
                eventLog.classList.add('open');
                toggle.style.display = 'none';
            } else {
                eventLog.classList.remove('open');
                toggle.style.display = 'flex';
            }
            
            // Update event count when opening
            if (eventLogOpen && window.app && window.app.gameBoard) {
                window.app.gameBoard.updateEventLogStats();
            }
        }

        // Clear event log
        function clearRightEventLog() {
            if (window.app && window.app.gameBoard) {
                window.app.gameBoard.clearEventLog();
                document.getElementById('eventLogPanelContent').innerHTML = '<div class="event-log-empty">Event log cleared...</div>';
            }
        }

        // Test function to simulate damage (for testing FFTCG damage system)
        function testTakeDamage(player, amount = 1) {
            if (window.app && window.app.gameBoard) {
                window.app.gameBoard.takeDamage(player, amount);
            } else {
                console.warn('GameBoard not initialized yet');
            }
        }

        // Test function to check event log functionality
        function testEventLog() {
            console.log('=== EVENT LOG DEBUG TEST ===');
            
            // Check DOM elements first
            const eventLogArea = document.getElementById('eventLogArea');
            const eventLogContent = document.getElementById('eventLogContent');
            const eventLogPanelContent = document.getElementById('eventLogPanelContent');
            
            console.log('Event log area:', eventLogArea);
            console.log('Event log content (main):', eventLogContent);
            console.log('Event log panel content (right):', eventLogPanelContent);
            
            // Test basic container functionality FIRST
            console.log('=== BASIC CONTAINER TEST ===');
            const testEntry = document.createElement('div');
            testEntry.textContent = 'MANUAL TEST ENTRY - Should appear INSIDE the Game Events Log box';
            testEntry.style.background = 'red';
            testEntry.style.color = 'white';
            testEntry.style.padding = '10px';
            testEntry.style.margin = '5px';
            testEntry.style.border = '2px solid yellow';
            
            console.log('Adding manual test entry to eventLogContent...');
            eventLogContent.appendChild(testEntry);
            
            // Check where it appeared
            console.log('Container rect:', eventLogContent.getBoundingClientRect());
            console.log('Test entry rect:', testEntry.getBoundingClientRect());
            
            if (window.app && window.app.gameBoard) {
                const gameBoard = window.app.gameBoard;
                console.log('GameBoard event log content:', gameBoard.eventLog.content);
                console.log('Are they the same element?', eventLogContent === gameBoard.eventLog.content);
                
                // Test GameBoard method
                console.log('=== GAMEBOARD METHOD TEST ===');
                gameBoard.addEventLogEntry('phase-change', 'Test phase change message via GameBoard', {});
                
                // Check final state
                console.log('Final eventLogContent children:', eventLogContent.children);
            } else {
                console.warn('GameBoard not initialized yet');
            }
        }

        // Simple direct test without GameBoard
        function testDirectDOM() {
            console.log('=== DIRECT DOM TEST ===');
            const eventLogArea = document.getElementById('eventLogArea');
            const eventLogContent = document.getElementById('eventLogContent');
            
            if (!eventLogContent) {
                console.error('eventLogContent not found!');
                return;
            }
            
            console.log('Found eventLogArea:', eventLogArea);
            console.log('Found eventLogContent:', eventLogContent);
            console.log('eventLogContent parent:', eventLogContent.parentElement);
            
            // CHECK SCROLL STATE - This is key!
            console.log('üîç SCROLL INVESTIGATION:');
            console.log('eventLogContent.scrollTop:', eventLogContent.scrollTop);
            console.log('eventLogContent.scrollHeight:', eventLogContent.scrollHeight);
            console.log('eventLogContent.clientHeight:', eventLogContent.clientHeight);
            console.log('Is container scrolled?', eventLogContent.scrollTop > 0);
            
            // Check the exact position and size
            const containerRect = eventLogContent.getBoundingClientRect();
            const areaRect = eventLogArea.getBoundingClientRect();
            
            console.log('eventLogArea position:', areaRect);
            console.log('eventLogContent position:', containerRect);
            
            // Add a very obvious test element
            const directTest = document.createElement('div');
            directTest.style.cssText = `
                background: lime !important; 
                color: black !important; 
                padding: 15px !important; 
                border: 3px solid red !important; 
                margin: 10px !important;
                position: relative !important;
                z-index: 9999 !important;
            `;
            directTest.textContent = '‚≠ê DIRECT TEST - This should be INSIDE the box ‚≠ê';
            
            eventLogContent.appendChild(directTest);
            
            // Check where it ended up
            const testRect = directTest.getBoundingClientRect();
            console.log('Test element position (viewport):', testRect);
            
            // CORRECT TEST: Check if element is within container's CLIENT AREA
            // Not viewport coordinates, but relative to the container's scrollable area
            const isVisibleInContainer = testRect.top >= containerRect.top && 
                                       testRect.bottom <= containerRect.bottom &&
                                       testRect.left >= containerRect.left && 
                                       testRect.right <= containerRect.right;
            
            console.log('Is test element VISIBLE in container viewport?', isVisibleInContainer);
            
            // BETTER TEST: Check if element is actually contained within the DOM hierarchy
            const isContainedInDOM = eventLogContent.contains(directTest);
            console.log('‚úÖ Is element CONTAINED in DOM hierarchy?', isContainedInDOM);
            
            // ULTIMATE TEST: Check if any elements are actually escaping by testing overflow
            const containerStyle = window.getComputedStyle(eventLogContent);
            console.log('Container overflow-y:', containerStyle.overflowY);
            console.log('Container height:', containerStyle.height);
            
            if (eventLogContent.scrollHeight > eventLogContent.clientHeight) {
                console.log('üìù Container is scrollable - this is NORMAL behavior');
                console.log('Scroll height:', eventLogContent.scrollHeight);
                console.log('Client height:', eventLogContent.clientHeight);
                console.log('Elements with negative Y are just scrolled out of view - NOT escaped!');
            }
        }

        // Debug function to find all event log related elements
        function debugEventLogDOM() {
            console.log('=== EVENT LOG DOM ANALYSIS ===');
            
            // Find all elements with eventLog in ID
            const allEventLogElements = document.querySelectorAll('[id*="eventLog"]');
            console.log('All elements with eventLog in ID:', allEventLogElements);
            
            // Check for duplicates
            const eventLogContent = document.querySelectorAll('#eventLogContent');
            console.log('Elements with ID eventLogContent:', eventLogContent.length, eventLogContent);
            
            const eventLogArea = document.querySelectorAll('#eventLogArea');
            console.log('Elements with ID eventLogArea:', eventLogArea.length, eventLogArea);
            
            // Check current structure
            const mainContainer = document.getElementById('eventLogContent');
            if (mainContainer) {
                console.log('Main container children:', mainContainer.children);
                console.log('Main container innerHTML:', mainContainer.innerHTML);
                
                // Check if there are any absolutely positioned children
                Array.from(mainContainer.children).forEach((child, index) => {
                    const style = window.getComputedStyle(child);
                    console.log(`Child ${index}:`, child);
                    console.log(`  Position: ${style.position}`);
                    console.log(`  Display: ${style.display}`);
                    console.log(`  Location:`, child.getBoundingClientRect());
                });
            }
        }

        // Mulligan System Functions
        function showMulliganModal() {
            const modal = document.getElementById('mulliganModal');
            if (!modal) {
                console.error('Mulligan modal not found');
                return;
            }

            // Get current player hand from game engine
            if (window.app && window.app.gameEngine && window.app.gameEngine.gameState) {
                const playerHandIds = window.app.gameEngine.gameState.players[0].zones.hand || [];
                console.log('üÉè Player hand card IDs:', playerHandIds);
                populateMulliganHand(playerHandIds);
            }

            modal.classList.add('show');
            document.body.style.overflow = 'hidden';
            console.log('üîÑ Showing mulligan modal');
        }

        function hideMulliganModal() {
            const modal = document.getElementById('mulliganModal');
            if (modal) {
                modal.classList.remove('show');
                document.body.style.overflow = '';
                console.log('‚úÖ Hiding mulligan modal');
            }
        }

        function populateMulliganHand(handCardIds) {
            const container = document.getElementById('mulliganHandCards');
            if (!container) return;

            container.innerHTML = '';

            handCardIds.forEach((cardId, index) => {
                // Look up the actual card data from the card database
                let card = null;
                if (window.app && window.app.gameBoard && window.app.gameBoard.cardDatabase) {
                    card = window.app.gameBoard.cardDatabase.getCard(cardId);
                }

                const cardElement = document.createElement('div');
                cardElement.className = 'mulligan-card';
                
                if (card) {
                    // Get card image HTML using the same logic as GameBoard
                    let cardImageHTML = '';
                    if (window.app && window.app.gameBoard && window.app.gameBoard.getCardImageHTML) {
                        cardImageHTML = window.app.gameBoard.getCardImageHTML(card);
                    }

                    cardElement.innerHTML = `
                        <div class="mulligan-card-image">
                            ${cardImageHTML || 
                                `<div class="mulligan-card-placeholder">
                                    <div class="placeholder-icon">üé¥</div>
                                    <div class="placeholder-text">${card.name}</div>
                                </div>`
                            }
                        </div>
                        <div class="mulligan-card-info">
                            <div class="mulligan-card-name">${card.name}</div>
                            <div class="mulligan-card-cost">${card.cost || '?'}</div>
                        </div>
                    `;
                } else {
                    // Fallback if card lookup fails
                    cardElement.innerHTML = `
                        <div class="mulligan-card-image">
                            <div class="mulligan-card-placeholder">
                                <div class="placeholder-icon">‚ùì</div>
                            </div>
                        </div>
                        <div class="mulligan-card-info">
                            <div class="mulligan-card-name">Card ${cardId}</div>
                            <div class="mulligan-card-cost">?</div>
                        </div>
                    `;
                }
                
                container.appendChild(cardElement);
            });

            console.log(`üìã Populated mulligan preview with ${handCardIds.length} cards`);
        }

        function keepOpeningHand() {
            console.log('‚úÖ Player chose to keep opening hand');
            
            // Complete mulligan phase and proceed to active play
            if (window.app && window.app.gameEngine) {
                window.app.gameEngine.completeMulliganPhase();
            }
            
            hideMulliganModal();
            
            // Add event log entry
            if (window.app && window.app.gameBoard) {
                window.app.gameBoard.addEventLogEntry('mulligan', 'Player kept their opening hand');
            }
        }

        function mulliganOpeningHand() {
            console.log('üîÑ Player chose to mulligan opening hand');
            
            // Perform mulligan through game engine
            if (window.app && window.app.gameEngine) {
                window.app.gameEngine.redrawHand(0); // Player index 0
                
                // Complete mulligan phase and proceed to active play
                window.app.gameEngine.completeMulliganPhase();
            }
            
            hideMulliganModal();
            
            // Add event log entry
            if (window.app && window.app.gameBoard) {
                window.app.gameBoard.addEventLogEntry('mulligan', 'Player mulliganed their opening hand');
            }
        }

        // Dynamic Card Grid Column Management
        function updateCardGridColumns() {
            const cardGrid = document.getElementById('cardGrid');
            if (!cardGrid) return;
            
            // Get the actual width of the card grid container
            const containerWidth = cardGrid.offsetWidth;
            
            // Card dimensions: 140px width + 16px gap = 156px per card
            const cardWidth = 140;
            const cardGap = 16;
            const cardTotalWidth = cardWidth + cardGap;
            
            // Calculate how many columns can fit
            const maxColumns = Math.floor((containerWidth + cardGap) / cardTotalWidth);
            
            // Ensure minimum of 1 column, maximum of 10 for performance
            const columns = Math.max(1, Math.min(maxColumns, 10));
            
            // Update the grid template columns
            cardGrid.style.gridTemplateColumns = `repeat(${columns}, ${cardWidth}px)`;
            
            console.log(`üìä Card grid updated: ${containerWidth}px container ‚Üí ${columns} columns (${cardWidth}px each)`);
        }
        
        // Call updateCardGridColumns on window resize
        window.addEventListener('resize', updateCardGridColumns);

        // Enhanced Deck View Functions
        let deckSortMode = 'name';
        let deckViewCompact = false;
        
        function updateDeckName() {
            const deckNameInput = document.getElementById('deckName');
            if (deckNameInput && deckNameInput.value.trim()) {
                document.getElementById('saveDeckBtn').disabled = false;
                console.log(`üìù Deck name updated: ${deckNameInput.value}`);
            } else {
                document.getElementById('saveDeckBtn').disabled = true;
            }
        }
        
        function toggleDeckSort() {
            const sortBtn = document.getElementById('deckSortBtn');
            const modes = ['name', 'cost', 'element', 'type'];
            const currentIndex = modes.indexOf(deckSortMode);
            deckSortMode = modes[(currentIndex + 1) % modes.length];
            
            sortBtn.textContent = `SORT: ${deckSortMode.toUpperCase()}`;
            updateDeckDisplay();
            console.log(`üîÄ Deck sort changed to: ${deckSortMode}`);
        }
        
        function toggleDeckView() {
            const viewBtn = document.getElementById('deckViewBtn');
            deckViewCompact = !deckViewCompact;
            
            viewBtn.textContent = deckViewCompact ? 'DETAILED' : 'COMPACT';
            viewBtn.classList.toggle('active', deckViewCompact);
            updateDeckDisplay();
            console.log(`üëÅÔ∏è Deck view toggled: ${deckViewCompact ? 'compact' : 'detailed'}`);
        }
        
        function updateDeckStats() {
            if (!window.app?.deckManager) return;
            
            const deck = window.app.deckManager.getCurrentDeck();
            const cards = deck || [];
            
            // Update card count
            const countElement = document.getElementById('deckCardCount');
            if (countElement) {
                countElement.textContent = `${cards.length}/50`;
                countElement.style.color = cards.length > 50 ? '#ff6b6b' : '#80CFFF';
            }
            
            // Calculate average cost
            const totalCost = cards.reduce((sum, card) => sum + (card.cost || 0), 0);
            const avgCost = cards.length > 0 ? (totalCost / cards.length).toFixed(1) : '0.0';
            const avgCostElement = document.getElementById('avgCost');
            if (avgCostElement) avgCostElement.textContent = avgCost;
            
            // Count unique elements
            const elements = new Set(cards.map(card => card.element).filter(Boolean));
            const elementCountElement = document.getElementById('elementCount');
            if (elementCountElement) elementCountElement.textContent = elements.size;
            
            // Update element distribution
            updateElementDistribution(cards);
            
            // Update validation messages
            updateDeckValidation(cards);
            
            console.log(`üìä Deck stats updated: ${cards.length} cards, ${avgCost} avg cost, ${elements.size} elements`);
        }
        
        function updateElementDistribution(cards) {
            const distributionElement = document.getElementById('elementDistribution');
            if (!distributionElement) return;
            
            const elementColors = {
                fire: '#ff4444', ice: '#44ddff', wind: '#44ff44', lightning: '#aa44ff',
                water: '#4488ff', earth: '#ffaa44', light: '#ffffff', dark: '#888888'
            };
            
            const elementCounts = {};
            cards.forEach(card => {
                if (card.element) {
                    elementCounts[card.element] = (elementCounts[card.element] || 0) + 1;
                }
            });
            
            const totalCards = cards.length;
            let barsHtml = '';
            
            Object.entries(elementCounts).forEach(([element, count]) => {
                const percentage = totalCards > 0 ? (count / totalCards) * 100 : 0;
                const color = elementColors[element.toLowerCase()] || '#80CFFF';
                
                barsHtml += `
                    <div style="flex: ${percentage}; background: ${color}; height: 20px; border-radius: 2px; display: flex; align-items: center; justify-content: center; font-size: 0.6rem; font-weight: 600; color: white; text-shadow: 0 1px 2px rgba(0,0,0,0.8);" 
                         title="${element}: ${count} cards (${percentage.toFixed(1)}%)">
                        ${count > 2 ? count : ''}
                    </div>
                `;
            });
            
            distributionElement.innerHTML = barsHtml || '<div style="color: #9fb6cf; text-align: center; font-size: 0.7rem; padding: 6px;">No cards in deck</div>';
        }
        
        function updateDeckValidation(cards) {
            const validationElement = document.getElementById('deckValidation');
            if (!validationElement) return;
            
            let messages = [];
            
            if (cards.length > 50) {
                messages.push('<span style="color: #ff6b6b;">‚ö†Ô∏è Deck exceeds 50 cards</span>');
            } else if (cards.length < 40) {
                messages.push('<span style="color: #ffaa44;">‚ö†Ô∏è Deck needs at least 40 cards</span>');
            }
            
            // Check for 3-copy limit violations
            const cardCounts = {};
            cards.forEach(card => {
                const name = card.name || card.id;
                cardCounts[name] = (cardCounts[name] || 0) + 1;
            });
            
            const violations = Object.entries(cardCounts).filter(([name, count]) => count > 3);
            if (violations.length > 0) {
                violations.forEach(([name, count]) => {
                    messages.push(`<span style="color: #ff6b6b;">‚ö†Ô∏è ${name}: ${count} copies (max 3)</span>`);
                });
            }
            
            if (messages.length === 0 && cards.length >= 40 && cards.length <= 50) {
                messages.push('<span style="color: #44ff44;">‚úÖ Deck is tournament legal</span>');
            }
            
            validationElement.innerHTML = messages.join('<br>') || '';
        }
        
        function updateDeckDisplay() {
            // This function would update the deck list display based on sort and view settings
            // Integration with existing deck display logic would happen here
            console.log(`üîÑ Updating deck display (sort: ${deckSortMode}, compact: ${deckViewCompact})`);
        }

        // Initialize card hover tracking when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            setupCardHoverTracking();
            setupZoneClickHandlers();
            
            // Initialize enhanced deck view
            updateDeckStats();
            
            // Initialize card grid columns after DOM is loaded
            setTimeout(() => {
                updateCardGridColumns();
            }, 100); // Small delay to ensure layout is complete
            
            // Listen for deck builder view activation - Simplified approach
            const observer = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                    if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                        const target = mutation.target;
                        if (target.id === 'deck-builderView' && target.classList.contains('active')) {
                            console.log('üéØ Deck builder view activated - using DeckBuilder.js system');
                            
                            // Use DeckBuilder.js system since it's working
                            setTimeout(() => {
                                if (window.app?.deckBuilder) {
                                    // Just refresh the existing DeckBuilder.js display
                                    window.app.deckBuilder.refreshCardDisplay();
                                    console.log('‚úÖ DeckBuilder.js refreshed successfully');
                                }
                            }, 100); // Much shorter delay since we're just refreshing
                        }
                    }
                });
            });
            
            const deckBuilderView = document.getElementById('deck-builderView');
            if (deckBuilderView) {
                observer.observe(deckBuilderView, { attributes: true });
            }
            
            // Event log positioning has been fixed - no automatic testing needed
        });
    </script>
    
    <!-- Import Starfield Animation for Classic FF Menu -->
    <script type="module" src="src/components/Starfield.js"></script>
</body>
</html>